<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2021s on Bokyung&#39;s Note</title>
    <link>https://bokyung.dev/ja/2021/</link>
    <description>Recent content in 2021s on Bokyung&#39;s Note</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 17 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://bokyung.dev/ja/2021/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>AWS SAMを利用して、Lambda関数デプロイする</title>
      <link>https://bokyung.dev/ja/2021/05/17/lambda-sam-deploy/</link>
      <pubDate>Mon, 17 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://bokyung.dev/ja/2021/05/17/lambda-sam-deploy/</guid>
      <description>前のPostにCloudFrontとLambda@Edgeを利用して画像をリサイズさせる 方法に関する内容がありましたが、AWS SAMを利用してCloudFormationでLambda関数をデプロイする方法をまとめてみました。
デプロイ順番 SAM CLIインストール Install SAM CLI 
私は SAM CLI, version 1.23.0を利用しました。
template.yaml作成 CloudFormation基盤のテンプレート(template.yaml)を作成します。
. ├── index.js ├── node_modules/ ├── template.yaml ├── package-lock.json └── package.json  SAM deployを利用した、コードのパッケージングとデプロイ SAM deploy \  --template-file template.yaml \  # Lambda@edgeの場合はus-east-1リージョンに作成したBucketが必要です。 --s3-bucket &amp;lt;zipファイルをアップロードするBucket name&amp;gt; \  --s3-prefix SAM \  --stack-name &amp;lt;cloudformation スタック名&amp;gt; \  --capabilities CAPABILITY_NAMED_IAM \  --region &amp;lt;cloudformationをデプロイするリージョン名&amp;gt; \  --profile &amp;lt;profile name&amp;gt; SAMはデプロイ時、
 アプリケーションのコードを圧縮して、S3へアップロード CodeUriがS3 pathに変換されたCloudFormationテンプレートファイル作成、S3へアップロード S3にアップロードされたファイルを利用して、Cloudformationのスタック作成してデプロイ  Cloudformationコンソール上でTemplateの中身を確認するとCodeUriがS3のパスになっていることが確認できます。</description>
    </item>
    
    <item>
      <title>CloudFrontとLambda@Edgeを利用して画像をリサイズさせる</title>
      <link>https://bokyung.dev/ja/2021/05/14/lambda-edge-resize/</link>
      <pubDate>Fri, 14 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://bokyung.dev/ja/2021/05/14/lambda-edge-resize/</guid>
      <description>リサイズされた画像をS3へ保存せずに、原本のみ利用してリサイズさせる方法がないか調べてみましたが、Lambda@Edgeを利用してリサイズさせる方法があったので、試してみました。
Lambda@Edge動作概要    Lambda@EdgeはCloudFrontへアクセスする時に実行されるLambdaの拡張版です。 CloudFrontイベント発生時、Lambda関数の実行が可能です。 イベントには４種類があります。
 Viewer Request : CloudFrontがビューアーからのリクエストを受け、リクエストしたオブジェクトがedge cacheにあるかを確認する前に関数を実行します。 Origin Request : CloudFrontがオリジンにリクエストを渡す場合のみ実行されます。 リクエストしたオブジェクトがedge cacheにある場合は関数は実行されません。 Origin Response : CloudFrontがオリジンからレスポンスを受け取った後、レスポンスへオブジェクトをcacheする前に関数を実行します。 Viewer Response : リクエストしたオブジェクトをビューアーに返却する前に実行されます。 この関数は、オブジェクトがedge cacheに既に存在しているか否かに関わらず実行されます。  Lambda@Edge 注意点  環境変数は利用不可 us-east-1 リージョンのみ対応 イベントタイプによって異なるクォータ    Entity Origin request and response event quotas Viewer request and response event quotas     Function memory size Same as Lambda quotas（128 MB to 10,240 MB） 128 MB   Function timeout 30 seconds 5 seconds   Size of a response 1 MB 40 KB   Maximum compressed size of a Lambda function and any included libraries 50 MB 1 MB      イメージリサイジング処理実装 イメージリサイジング処理の流れ Origin Responseイベント発生時、Lambda@Edge関数を実行する方法を利用しました。</description>
    </item>
    
    <item>
      <title>Sentryをreact.jsプロジェクトへ適用する</title>
      <link>https://bokyung.dev/ja/2021/04/16/sentry-react/</link>
      <pubDate>Fri, 16 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://bokyung.dev/ja/2021/04/16/sentry-react/</guid>
      <description>公式サイト の見ながらreact.jsプロジェクトにSentryを適用してみました。
バージョン  react 17.0.1 Sentry  @sentry/react 6.2.5 @sentry/tracing 6.2.5    Sentryへプロジェクト追加及び設定  Sentryへログイン後、プロジェクト作成。 Client Keys (DSN)メニューに書いてある、DSNキーをコピーしておきます。    sentry パッケージインストール npm install --save @sentry/react @sentry/tracing  index.jsにSentryを初期化するコードを追加します。 import React from &amp;quot;react&amp;quot;; import ReactDOM from &amp;quot;react-dom&amp;quot;; import * as Sentry from &amp;quot;@sentry/react&amp;quot;; import { Integrations } from &amp;quot;@sentry/tracing&amp;quot;; import App from &amp;quot;./App&amp;quot;; import &amp;quot;./index.css&amp;quot;; Sentry.init({ // 全ての環境に設定時 dsn: &amp;quot;https://xxxxxxxxxxxxxxxxxxxxxxxxxxx@xxxxxx.ingest.sentry.io/xxxxx&amp;quot;, // productionのみ設定時 dsn: process.env.NODE_ENV === &amp;quot;production&amp;quot; ?</description>
    </item>
    
    <item>
      <title>Flyway 一部手動で作業する</title>
      <link>https://bokyung.dev/ja/2021/04/15/flyway-springboot/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://bokyung.dev/ja/2021/04/15/flyway-springboot/</guid>
      <description>Spring BootプロジェクトでFlywayを利用していますが、手動で作業しないといけないケースが出てきます。データが多いテーブルに手動でカラムを追加したり、indexを追加したりなどなど。 手動で作業した場合は誰がいつ作業したのかが管理できないため、履歴管理する方法がないかと思い、公式ドキュメントを読んでみました。 ignoreIgnoredMigrationsパラメーターを検証してみました。
バージョン  Flyway  flyway-core 7.1.1   Spring Boot 2.4.1  テーブル追加しサーバー起動  sqlバージョンファイル追加  V1.0.0__Create_accounts.sql CREATE TABLE accounts ( user_id serial PRIMARY KEY, username VARCHAR ( 50 ) UNIQUE NOT NULL, password VARCHAR ( 50 ) NOT NULL, created_on TIMESTAMP NOT NULL );  V1.1.0__Modify_accounts.sql ALTER TABLE accounts ADD COLUMN last_login TIMESTAMP;    サーバー起動  サーバー起動時、DBへ正常的にSQL文が反映されました。 2021-04-15 11:06:14.196 INFO 7888 --- [ restartedMain] o.</description>
    </item>
    
    <item>
      <title>SentryをSpringBootプロジェクトへ適用する</title>
      <link>https://bokyung.dev/ja/2021/04/15/sentry-springboot/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://bokyung.dev/ja/2021/04/15/sentry-springboot/</guid>
      <description>react.jsへSentryを適用しようと思い、公式ドキュメントを見てみると対応言語の中にSpringBootがあったため、試してみました。
バージョン  Spring Boot 2.4.1 Sentry  sentry-spring-boot-starter 4.3.0    Sentryへプロジェクト追加及び設定   Sentryへログイン後、プロジェクト作成。
  Client Keys (DSN)メニューに書いてある、DSNキーをコピーしておきます。     build.gradle.ktsに依存関係を追加します。
 build.gradle.kts implementation(&amp;quot;io.sentry:sentry-spring-boot-starter:4.3.0&amp;quot;)     application.properties에 DSN (Data Source Name)を設定します。
 application.properties # DSN設定 sentry.dsn=https://xxxxxxxxxxxxxxxxxxxxxxxxxxx@xxxxxx.ingest.sentry.io/xxxxx # エラートレース設定 sentry.enable-tracing=true  application-development.properties # 各環境の設定も可能です。 sentry.environment=development     Sentryにエラーを送るための設定
 サンプルプロジェクトがRestApiプロジェクトなので、@RestControllerAdviceを利用して共通エラー処理を追加しました。 @RestControllerAdvice class SampleControllerAdvice { @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(MissingPathVariableException::class) fun handleMissingPathVariable(ex: MissingPathVariableException): Map&amp;lt;String, String&amp;gt; { Sentry.</description>
    </item>
    
    <item>
      <title>Jenkins環境でSpring Batch Jobを実行する</title>
      <link>https://bokyung.dev/ja/2021/03/31/jenkins-batch-job/</link>
      <pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://bokyung.dev/ja/2021/03/31/jenkins-batch-job/</guid>
      <description>JenkinsでSpring Batch Jobを実行してみました。
Jenkinsの環境  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI名 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    環境変数とプラグイン設定   複数のJobを登録する場合は、各Jobに同じパラメータを設定することになりますが、環境変数に登録しておくと一括管理ができます。
  Jobパラメーターに実行日を渡すために、timestamperプラグインを利用しました。     Manage Jenkins &amp;gt; System Configuration &amp;gt; Configure System &amp;gt; Global properties &amp;gt; Environment variablesでJob共通で利用している環境変数を設定します。     Batch Job登録  New Item &amp;gt; Freestyle projectを選び、JOBを登録します。     java -jar ${JAR_NAME} ${DB_HOST} ${DB_PORT} ${DB_NAME} ${DB_USER} ${DB_PASSWORD} \ --spring.</description>
    </item>
    
    <item>
      <title>Jenkins環境でSpring BatchプロジェクトをGradleビルドする</title>
      <link>https://bokyung.dev/ja/2021/03/30/jenkins-gradle-build/</link>
      <pubDate>Tue, 30 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://bokyung.dev/ja/2021/03/30/jenkins-gradle-build/</guid>
      <description>Spring BatchのJob Runnerを調査していましたが、その中でJenkinsでbatchプロジェクトをgradleビルドをしてみました。
Jenkinsの環境  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI名 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    認証情報登録 Github ID/PASSWORD認証方法   JenkinsでRepository関連作業ができるようにGithub上でPersonal access tokensを発行します。 ( Settings &amp;gt; Developer settings &amp;gt; Personal access tokens )     Manage Jenkins &amp;gt; Manage Credentials &amp;gt; domainにあるglobalをクリックします。     KindはUsername with passwordを選び、パスワード欄にはPersonal access tokens値を入力し認証情報を追加します。     Github SSH 認証方法   SSH鍵を作成します。       Githubプロジェクト設定のDeploy keysに公開鍵を追加します。     KindはSSH Username with private keyを選び、Private Key &amp;gt; Enter directlyに秘密鍵を追加します。     Gradle, JDK設定  プロジェクトで利用するGradleとJDKを Manage Jenkins &amp;gt; System Configuration &amp;gt; Global Tool Configurationにて設定します。一つのバージョンのみ設定した場合は、各JOBでデフォルトとして設定されます。複数のバージョンが登録されている場合は、JOB設定時バージョンを選べられます。     Job登録   New Item &amp;gt; Freestyle projectを選び、JOBを登録します。github access tokens認証の場合は、Repository URLに git@github.</description>
    </item>
    
    <item>
      <title>Amazon Linux2にJenkinsをインストールする</title>
      <link>https://bokyung.dev/ja/2021/03/17/jenkins-install/</link>
      <pubDate>Wed, 17 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://bokyung.dev/ja/2021/03/17/jenkins-install/</guid>
      <description>ローカル環境でJenkinsを試しましたが、エラーになるケールがあったため、検証のために、Amazon Linux2にJenkinsをインストールしてみました。
構築するJenkinsの環境  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI名 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    EC2インスタンス作成及びJenkinsインストール EC2インスタンス作成ととセキュリティグループ設定   一番上に表示されているAMIを利用して作成しました。     Jenkinsアクセス用の8080ポートと、SSH接続用の22ポートを設定します。     Jenkinsインストール  Jenkins公式サイトのインストール方法 の順番通りに実行。  sudo wget -O /etc/yum.repos.d/jenkins.repo \ https://pkg.jenkins.io/redhat-stable/jenkins.repo sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key sudo yum upgrade sudo yum install jenkins java-1.8.0-openjdk-devel.x86_64 sudo systemctl daemon-reload Jenkins 実行 sudo systemctl start jenkins サービス実行状態を確認し、active状態になっていることを確認します。   Jenkins 初期設定   Jenkinsへアクセスします。http://xxxxxxxxxx:8080/</description>
    </item>
    
    <item>
      <title>CircleCIのContextsを利用し、AWS ECSへデプロイする</title>
      <link>https://bokyung.dev/ja/2021/02/02/clrcleci-ecs-deploy/</link>
      <pubDate>Tue, 02 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://bokyung.dev/ja/2021/02/02/clrcleci-ecs-deploy/</guid>
      <description>springboot + kotlinで開発したbackendAPIをCircleCIを利用してデプロイしています。 staging/production環境毎の環境変数はContextsを利用すればもっと簡単に設定することが可能です。
Contexts設定 Organization Settings &amp;gt; Contexts でサービスの各環境毎の環境変数を設定します。 staging/productionの環境名で追加しました。   staging環境の環境変数です。 ecrとecsのorbsを利用するため、AWSの環境変数を追加し、プロジェクト内で共通で利用するためにSERVICE_PREFIXを追加しました。   CircleCI config.yml 設定 build-and-push-image  backend-buildを実行します。 releaseブランチの場合、build-and-push-image-stagingを実行します。 masterブランチの場合、build-and-push-image-productionを実行します。 contextにはCircleCI Contextsで指定した名前を指定します。  version: 2.1 orbs: aws-ecr: circleci/aws-ecr@6.15.3 aws-ecs: circleci/aws-ecs@1.4.0 gradle: circleci/gradle@2.2.0 executors: openjdk-executor: docker: - image: circleci/openjdk:14-jdk-buster-node-browsers ..... jobs: backend-build: executor: openjdk-executor ..... workflows: build-deploy: jobs: - backend-build - aws-ecr/build-and-push-image: name: build-and-push-image-staging requires: - backend-build context: DEMO_STAGING attach-workspace: true checkout: false repo: &amp;#39;${SERVICE_PREFIX}&amp;#39; tag: &amp;#39;latest,${CIRCLE_SHA1}&amp;#39; filters: branches: only: - /release\/.</description>
    </item>
    
  </channel>
</rss>
