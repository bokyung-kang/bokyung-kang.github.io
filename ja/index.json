[{"content":"公式サイト の見ながらreact.jsプロジェクトにSentryを適用してみました。\nバージョン  react 17.0.1 Sentry  @sentry/react 6.2.5 @sentry/tracing 6.2.5    Sentryへプロジェクト追加及び設定  Sentryへログイン後、プロジェクト作成。 Client Keys (DSN)メニューに書いてある、DSNキーをコピーしておきます。    sentry パッケージインストール npm install --save @sentry/react @sentry/tracing  index.jsにSentryを初期化するコードを追加します。 import React from \u0026quot;react\u0026quot;; import ReactDOM from \u0026quot;react-dom\u0026quot;; import * as Sentry from \u0026quot;@sentry/react\u0026quot;; import { Integrations } from \u0026quot;@sentry/tracing\u0026quot;; import App from \u0026quot;./App\u0026quot;; import \u0026quot;./index.css\u0026quot;; Sentry.init({ // 全ての環境に設定時 dsn: \u0026quot;https://xxxxxxxxxxxxxxxxxxxxxxxxxxx@xxxxxx.ingest.sentry.io/xxxxx\u0026quot;, // productionのみ設定時 dsn: process.env.NODE_ENV === \u0026quot;production\u0026quot; ? \u0026quot;https://xxxxxxxxxxxxxxxxxxxxxxxxxxx@xxxxxx.ingest.sentry.io/xxxxx\u0026quot; : false, integrations: [new Integrations.BrowserTracing()], environment: process.env.NODE_ENV, tracesSampleRate: 1.0, }); ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026quot;root\u0026quot;) );  Sentryへエラーを送るための設定  api実行時、エラーが発生したらsentryにエラーを送るように追加しました。 import * as Sentry from \u0026quot;@sentry/react\u0026quot;; ... ... useEffect(() =\u0026gt; { fetchPost(); },[]); const fetchPost = () =\u0026gt; { PostDataService.getPost(id) .then(response =\u0026gt; { setCurrentPost(response.data); }) .catch(e =\u0026gt; { Sentry.captureException(e); }); };     エラーを発生させ、Sentry側を確認  404エラーを発生させてみました。    Search by Traceをクリックするとエラートレースも可能です。    Dashboardも提供しています。カスタムDashboardはBusinessプランから使えるそうです。     利用したい機能は Teamプランでも十分に使えそうなので、公式ドキュメントの細かい部分を見てみたいと思います。\n","permalink":"https://bokyung.dev/ja/2021/04/16/sentry-react/","summary":"公式サイト の見ながらreact.jsプロジェクトにSentryを適用してみました。\nバージョン  react 17.0.1 Sentry  @sentry/react 6.2.5 @sentry/tracing 6.2.5    Sentryへプロジェクト追加及び設定  Sentryへログイン後、プロジェクト作成。 Client Keys (DSN)メニューに書いてある、DSNキーをコピーしておきます。    sentry パッケージインストール npm install --save @sentry/react @sentry/tracing  index.jsにSentryを初期化するコードを追加します。 import React from \u0026quot;react\u0026quot;; import ReactDOM from \u0026quot;react-dom\u0026quot;; import * as Sentry from \u0026quot;@sentry/react\u0026quot;; import { Integrations } from \u0026quot;@sentry/tracing\u0026quot;; import App from \u0026quot;./App\u0026quot;; import \u0026quot;./index.css\u0026quot;; Sentry.init({ // 全ての環境に設定時 dsn: \u0026quot;https://xxxxxxxxxxxxxxxxxxxxxxxxxxx@xxxxxx.ingest.sentry.io/xxxxx\u0026quot;, // productionのみ設定時 dsn: process.env.NODE_ENV === \u0026quot;production\u0026quot; ?","title":"Sentryをreact.jsプロジェクトへ適用する"},{"content":"Spring BootプロジェクトでFlywayを利用していますが、手動で作業しないといけないケースが出てきます。データが多いテーブルに手動でカラムを追加したり、indexを追加したりなどなど。 手動で作業した場合は誰がいつ作業したのかが管理できないため、履歴管理する方法がないかと思い、公式ドキュメントを読んでみました。 ignoreIgnoredMigrationsパラメーターを検証してみました。\nバージョン  Flyway  flyway-core 7.1.1   Spring Boot 2.4.1  テーブル追加しサーバー起動  sqlバージョンファイル追加  V1.0.0__Create_accounts.sql CREATE TABLE accounts ( user_id serial PRIMARY KEY, username VARCHAR ( 50 ) UNIQUE NOT NULL, password VARCHAR ( 50 ) NOT NULL, created_on TIMESTAMP NOT NULL );  V1.1.0__Modify_accounts.sql ALTER TABLE accounts ADD COLUMN last_login TIMESTAMP;    サーバー起動  サーバー起動時、DBへ正常的にSQL文が反映されました。 2021-04-15 11:06:14.196 INFO 7888 --- [ restartedMain] o.f.core.internal.command.DbValidate : Successfully validated 2 migrations (execution time 00:00.029s) 2021-04-15 11:06:14.209 INFO 7888 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Current version of schema \u0026quot;public\u0026quot;: \u0026lt;\u0026lt; Empty Schema \u0026gt;\u0026gt; 2021-04-15 11:06:14.218 INFO 7888 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Migrating schema \u0026quot;public\u0026quot; to version \u0026quot;1.0.0 - Create accounts\u0026quot; 2021-04-15 11:06:14.284 INFO 7888 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Migrating schema \u0026quot;public\u0026quot; to version \u0026quot;1.1.0 - Modify accounts\u0026quot; 2021-04-15 11:06:14.305 INFO 7888 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Successfully applied 2 migrations to schema \u0026quot;public\u0026quot; (execution time 00:00.104s)  flyway_schema_historyにV1.1.0まで反映されてういることが確認できます。    accountsテーブルにも変更されたカラムが反映されています。       手動でカラム変更しサーバー起動  手動でemailカラムを追加しサーバーを起動してみました。 ALTER TABLE accounts ADD COLUMN email VARCHAR ( 255 ) UNIQUE NOT NULL  accountsテーブルにも変更されたカラムが反映されています。この状態でサーバーを起動します。    データマイグレーションなしにサーバーが起動できました。 2021-04-15 11:02:38.735 INFO 30080 --- [ restartedMain] o.f.core.internal.command.DbValidate : Successfully validated 2 migrations (execution time 00:00.031s) 2021-04-15 11:02:38.749 INFO 30080 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Current version of schema \u0026quot;public\u0026quot;: 1.1.0 2021-04-15 11:02:38.750 INFO 30080 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Schema \u0026quot;public\u0026quot; is up to date. No migration necessary.   手動で作業したSQLをバージョン管理する  sqlバージョンファイル追加  V1.0.9__Modify_accounts.sql ALTER TABLE accounts ADD COLUMN email VARCHAR ( 255 ) UNIQUE NOT NULL    この状態でサーバーを起動すると当然ながらマイグレーション失敗してしまいます。 org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'flywayInitializer' defined in class path resource [org/springframework/boot/autoconfigure/flyway/FlywayAutoConfiguration$FlywayConfiguration.class]: Invocation of init method failed; nested exception is org.flywaydb.core.api.exception.FlywayValidateException: Validate failed: Migrations have failed validation at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1788) ~[spring-beans-5.3.2.jar:5.3.2] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:609) ~[spring-beans-5.3.2.jar:5.3.2]   ignoreIgnoredMigrations パラメータを利用する Flyway 公式 Document に色んなパラメータがありましたが、その中でignoreIgnoredMigrationsが目に入りました。 最新バージョンより前のバージョンファイルがあってもvalidate実行時、レポートされないと書かれています。\n application.propertiesに ignore-ignored-migrationsオプションをtrueに設定します。 spring.flyway.ignore-ignored-migrations=true  sqlバージョンファイル追加  V1.0.9__Modify_accounts.sql ALTER TABLE accounts ADD COLUMN email VARCHAR ( 255 ) UNIQUE NOT NULL    V1.0.9バージョンもカウントされ、データマイグレーションなしにサーバーが起動されました。 2021-04-15 11:26:09.613 INFO 20004 --- [ restartedMain] o.f.core.internal.command.DbValidate : Successfully validated 3 migrations (execution time 00:00.035s) 2021-04-15 11:26:09.626 INFO 20004 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Current version of schema \u0026quot;public\u0026quot;: 1.1.0 2021-04-15 11:26:09.628 INFO 20004 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Schema \u0026quot;public\u0026quot; is up to date. No migration necessary.   これからバージョン番号にルールを付け、手動で作業したファイルも管理していきます。\n","permalink":"https://bokyung.dev/ja/2021/04/15/flyway-springboot/","summary":"Spring BootプロジェクトでFlywayを利用していますが、手動で作業しないといけないケースが出てきます。データが多いテーブルに手動でカラムを追加したり、indexを追加したりなどなど。 手動で作業した場合は誰がいつ作業したのかが管理できないため、履歴管理する方法がないかと思い、公式ドキュメントを読んでみました。 ignoreIgnoredMigrationsパラメーターを検証してみました。\nバージョン  Flyway  flyway-core 7.1.1   Spring Boot 2.4.1  テーブル追加しサーバー起動  sqlバージョンファイル追加  V1.0.0__Create_accounts.sql CREATE TABLE accounts ( user_id serial PRIMARY KEY, username VARCHAR ( 50 ) UNIQUE NOT NULL, password VARCHAR ( 50 ) NOT NULL, created_on TIMESTAMP NOT NULL );  V1.1.0__Modify_accounts.sql ALTER TABLE accounts ADD COLUMN last_login TIMESTAMP;    サーバー起動  サーバー起動時、DBへ正常的にSQL文が反映されました。 2021-04-15 11:06:14.196 INFO 7888 --- [ restartedMain] o.","title":"Flyway 一部手動で作業する"},{"content":"react.jsへSentryを適用しようと思い、公式ドキュメントを見てみると対応言語の中にSpringBootがあったため、試してみました。\nバージョン  Spring Boot 2.4.1 Sentry  sentry-spring-boot-starter 4.3.0    Sentryへプロジェクト追加及び設定   Sentryへログイン後、プロジェクト作成。\n  Client Keys (DSN)メニューに書いてある、DSNキーをコピーしておきます。     build.gradle.ktsに依存関係を追加します。\n build.gradle.kts implementation(\u0026quot;io.sentry:sentry-spring-boot-starter:4.3.0\u0026quot;)     application.properties에 DSN (Data Source Name)を設定します。\n application.properties # DSN設定 sentry.dsn=https://xxxxxxxxxxxxxxxxxxxxxxxxxxx@xxxxxx.ingest.sentry.io/xxxxx # エラートレース設定 sentry.enable-tracing=true  application-development.properties # 各環境の設定も可能です。 sentry.environment=development     Sentryにエラーを送るための設定\n サンプルプロジェクトがRestApiプロジェクトなので、@RestControllerAdviceを利用して共通エラー処理を追加しました。 @RestControllerAdvice class SampleControllerAdvice { @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(MissingPathVariableException::class) fun handleMissingPathVariable(ex: MissingPathVariableException): Map\u0026lt;String, String\u0026gt; { Sentry.captureException(ex) val error: Map\u0026lt;String, String\u0026gt; = mapOf(\u0026quot;code\u0026quot; to \u0026quot;E0001\u0026quot;, \u0026quot;message\u0026quot; to \u0026quot;Parameter error\u0026quot;) return error } @ResponseStatus(HttpStatus.UNSUPPORTED_MEDIA_TYPE) @ExceptionHandler(HttpMediaTypeNotSupportedException::class) fun handleHttpMediaTypeNotSupported(ex: HttpMediaTypeNotSupportedException): Map\u0026lt;String, String\u0026gt; { Sentry.captureException(ex) val error: Map\u0026lt;String, String\u0026gt; = mapOf(\u0026quot;code\u0026quot; to \u0026quot;E0002\u0026quot;, \u0026quot;message\u0026quot; to \u0026quot;Unsupported Media Type\u0026quot;) return error } @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler(Exception::class) fun handleExceptions(ex: Exception): Map\u0026lt;String, String\u0026gt; { Sentry.captureException(ex) val error: Map\u0026lt;String, String\u0026gt; = mapOf(\u0026quot;code\u0026quot; to \u0026quot;E0003\u0026quot;, \u0026quot;message\u0026quot; to \u0026quot;Internal Server Error\u0026quot;) return error } }     エラーを発生させ、Sentry側を確認  Content typeを追加し、エラーを発生させてみました。    Search by Traceをクリックするとエラートレースも可能です。    Dashboardも提供しています。カスタムDashboardはBusinessプランから使えるそうです。     slackへ通知  slackとか他のサービスと連携するためには、Teamプランにする必要があります。     Businessプランの場合、Amazon SQSへデータ転送もできると書いてあるので、便利そうです。 後で 公式サイド をよく見てみます。\n","permalink":"https://bokyung.dev/ja/2021/04/15/sentry-springboot/","summary":"react.jsへSentryを適用しようと思い、公式ドキュメントを見てみると対応言語の中にSpringBootがあったため、試してみました。\nバージョン  Spring Boot 2.4.1 Sentry  sentry-spring-boot-starter 4.3.0    Sentryへプロジェクト追加及び設定   Sentryへログイン後、プロジェクト作成。\n  Client Keys (DSN)メニューに書いてある、DSNキーをコピーしておきます。     build.gradle.ktsに依存関係を追加します。\n build.gradle.kts implementation(\u0026quot;io.sentry:sentry-spring-boot-starter:4.3.0\u0026quot;)     application.properties에 DSN (Data Source Name)を設定します。\n application.properties # DSN設定 sentry.dsn=https://xxxxxxxxxxxxxxxxxxxxxxxxxxx@xxxxxx.ingest.sentry.io/xxxxx # エラートレース設定 sentry.enable-tracing=true  application-development.properties # 各環境の設定も可能です。 sentry.environment=development     Sentryにエラーを送るための設定\n サンプルプロジェクトがRestApiプロジェクトなので、@RestControllerAdviceを利用して共通エラー処理を追加しました。 @RestControllerAdvice class SampleControllerAdvice { @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(MissingPathVariableException::class) fun handleMissingPathVariable(ex: MissingPathVariableException): Map\u0026lt;String, String\u0026gt; { Sentry.","title":"SentryをSpringBootプロジェクトへ適用する"},{"content":"JenkinsでSpring Batch Jobを実行してみました。\nJenkinsの環境  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI名 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    環境変数とプラグイン設定   複数のJobを登録する場合は、各Jobに同じパラメータを設定することになりますが、環境変数に登録しておくと一括管理ができます。\n  Jobパラメーターに実行日を渡すために、timestamperプラグインを利用しました。     Manage Jenkins \u0026gt; System Configuration \u0026gt; Configure System \u0026gt; Global properties \u0026gt; Environment variablesでJob共通で利用している環境変数を設定します。     Batch Job登録  New Item \u0026gt; Freestyle projectを選び、JOBを登録します。     java -jar ${JAR_NAME} ${DB_HOST} ${DB_PORT} ${DB_NAME} ${DB_USER} ${DB_PASSWORD} \\ --spring.batch.job.names=${JOB_NAME} version=${BUILD_NUMBER} requestDate=${BUILD_TIMESTAMP} --spring.batch.job.enabled=true --spring.profiles.active=dev Batch Job実行  Jobを実行し、実行結果を確認します。  2021-03-31 13:09:56.358 INFO 3564 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path '' 2021-03-31 13:09:56.379 INFO 3564 --- [ main] c.e.sample.batch.BatchApplicationKt : Started BatchApplicationKt in 12.493 seconds (JVM running for 13.807) 2021-03-31 13:09:56.380 INFO 3564 --- [ main] o.s.b.a.b.JobLauncherApplicationRunner : Running default command line with: [version=17, requestDate=2021-03-31] 2021-03-31 13:09:56.516 INFO 3564 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=jpaJob]] launched with the following parameters: [{requestDate=2021-03-31, version=17}] 2021-03-31 13:09:56.600 INFO 3564 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [jpaPagingItemStep] 2021-03-31 13:09:57.071 INFO 3564 --- [ main] o.s.batch.core.step.AbstractStep : Step: [jpaPagingItemStep] executed in 471ms 2021-03-31 13:09:57.092 INFO 3564 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=jpaJob]] completed with the following parameters: [{requestDate=2021-03-31, version=17}] and the following status: [COMPLETED] in 521ms 2021-03-31 13:09:57.127 INFO 3564 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Shutting down ExecutorService 'applicationTaskExecutor' 2021-03-31 13:09:57.129 INFO 3564 --- [ main] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default' 2021-03-31 13:09:57.140 INFO 3564 --- [ main] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Shutdown initiated... 2021-03-31 13:09:57.155 INFO 3564 --- [ main] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Shutdown completed. Finished: SUCCESS BatchApplication.kt  Job実行終了し、applicationも終了させるための設定。  @EnableBatchProcessing @SpringBootApplication class BatchApplication fun main(args: Array\u0026lt;String\u0026gt;) { val context = runApplication\u0026lt;BatchApplication\u0026gt;(*args) val exitCode = SpringApplication.exit(context) System.exit(exitCode) } ","permalink":"https://bokyung.dev/ja/2021/03/31/jenkins-batch-job/","summary":"JenkinsでSpring Batch Jobを実行してみました。\nJenkinsの環境  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI名 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    環境変数とプラグイン設定   複数のJobを登録する場合は、各Jobに同じパラメータを設定することになりますが、環境変数に登録しておくと一括管理ができます。\n  Jobパラメーターに実行日を渡すために、timestamperプラグインを利用しました。     Manage Jenkins \u0026gt; System Configuration \u0026gt; Configure System \u0026gt; Global properties \u0026gt; Environment variablesでJob共通で利用している環境変数を設定します。     Batch Job登録  New Item \u0026gt; Freestyle projectを選び、JOBを登録します。     java -jar ${JAR_NAME} ${DB_HOST} ${DB_PORT} ${DB_NAME} ${DB_USER} ${DB_PASSWORD} \\ --spring.","title":"Jenkins環境でSpring Batch Jobを実行する"},{"content":"Spring BatchのJob Runnerを調査していましたが、その中でJenkinsでbatchプロジェクトをgradleビルドをしてみました。\nJenkinsの環境  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI名 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    認証情報登録 Github ID/PASSWORD認証方法   JenkinsでRepository関連作業ができるようにGithub上でPersonal access tokensを発行します。 ( Settings \u0026gt; Developer settings \u0026gt; Personal access tokens )     Manage Jenkins \u0026gt; Manage Credentials \u0026gt; domainにあるglobalをクリックします。     KindはUsername with passwordを選び、パスワード欄にはPersonal access tokens値を入力し認証情報を追加します。     Github SSH 認証方法   SSH鍵を作成します。       Githubプロジェクト設定のDeploy keysに公開鍵を追加します。     KindはSSH Username with private keyを選び、Private Key \u0026gt; Enter directlyに秘密鍵を追加します。     Gradle, JDK設定  プロジェクトで利用するGradleとJDKを Manage Jenkins \u0026gt; System Configuration \u0026gt; Global Tool Configurationにて設定します。一つのバージョンのみ設定した場合は、各JOBでデフォルトとして設定されます。複数のバージョンが登録されている場合は、JOB設定時バージョンを選べられます。     Job登録   New Item \u0026gt; Freestyle projectを選び、JOBを登録します。github access tokens認証の場合は、Repository URLに git@github.com:bokyung-kang/batch-testを入力しCredentialsはgithub認証を登録したUsernameを選択します。     ssh認証の場合はRepository URLに git@github.com:bokyung-kang/batch-testを入力しCredentialsはssh認証を登録したUsernameを選択します。     build script\nchmod +x gradlew # testを実行しないようにassembleを実行しました。 ./gradlew assemble # deploy-testへjarをコピー。 mkdir -p $JENKINS_HOME/workspace/deploy-test cp $WORKSPACE/build/libs/*.jar $JENKINS_HOME/workspace/deploy-test/.   Gradle Build  ビルドを実行し、Console Outputを見てみます。  [batch-test] $ /bin/sh -xe /tmp/jenkins568576160326820555.sh + chmod +x gradlew + ./gradlew assemble Starting a Gradle Daemon (subsequent builds will be faster) \u0026gt; Task :compileKotlin \u0026gt; Task :compileJava NO-SOURCE \u0026gt; Task :processResources \u0026gt; Task :classes \u0026gt; Task :bootJarMainClassName \u0026gt; Task :bootJar \u0026gt; Task :inspectClassesForKotlinIC \u0026gt; Task :jar SKIPPED \u0026gt; Task :assemble BUILD SUCCESSFUL in 33s 5 actionable tasks: 5 executed + mkdir -p /var/lib/jenkins/workspace/deploy-test + cp /var/lib/jenkins/workspace/batch-test/build/libs/batch-0.0.1-SNAPSHOT.jar /var/lib/jenkins/workspace/deploy-test/. Finished: SUCCESS  $JENKINS_HOME/workspace/deploy-test/にjarファイルがコピーされていることが確認できます。     ","permalink":"https://bokyung.dev/ja/2021/03/30/jenkins-gradle-build/","summary":"Spring BatchのJob Runnerを調査していましたが、その中でJenkinsでbatchプロジェクトをgradleビルドをしてみました。\nJenkinsの環境  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI名 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    認証情報登録 Github ID/PASSWORD認証方法   JenkinsでRepository関連作業ができるようにGithub上でPersonal access tokensを発行します。 ( Settings \u0026gt; Developer settings \u0026gt; Personal access tokens )     Manage Jenkins \u0026gt; Manage Credentials \u0026gt; domainにあるglobalをクリックします。     KindはUsername with passwordを選び、パスワード欄にはPersonal access tokens値を入力し認証情報を追加します。     Github SSH 認証方法   SSH鍵を作成します。       Githubプロジェクト設定のDeploy keysに公開鍵を追加します。     KindはSSH Username with private keyを選び、Private Key \u0026gt; Enter directlyに秘密鍵を追加します。     Gradle, JDK設定  プロジェクトで利用するGradleとJDKを Manage Jenkins \u0026gt; System Configuration \u0026gt; Global Tool Configurationにて設定します。一つのバージョンのみ設定した場合は、各JOBでデフォルトとして設定されます。複数のバージョンが登録されている場合は、JOB設定時バージョンを選べられます。     Job登録   New Item \u0026gt; Freestyle projectを選び、JOBを登録します。github access tokens認証の場合は、Repository URLに git@github.","title":"Jenkins環境でSpring BatchプロジェクトをGradleビルドする"},{"content":"ローカル環境でJenkinsを試しましたが、エラーになるケールがあったため、検証のために、Amazon Linux2にJenkinsをインストールしてみました。\n構築するJenkinsの環境  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI名 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    EC2インスタンス作成及びJenkinsインストール EC2インスタンス作成ととセキュリティグループ設定   一番上に表示されているAMIを利用して作成しました。     Jenkinsアクセス用の8080ポートと、SSH接続用の22ポートを設定します。     Jenkinsインストール  Jenkins公式サイトのインストール方法 の順番通りに実行。  sudo wget -O /etc/yum.repos.d/jenkins.repo \\ https://pkg.jenkins.io/redhat-stable/jenkins.repo sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key sudo yum upgrade sudo yum install jenkins java-1.8.0-openjdk-devel.x86_64 sudo systemctl daemon-reload Jenkins 実行 sudo systemctl start jenkins サービス実行状態を確認し、active状態になっていることを確認します。   Jenkins 初期設定   Jenkinsへアクセスします。http://xxxxxxxxxx:8080/\n  初期パスワードを入力します。     プラグインをインストールします。     初期ユーザーを登録します。     インスタンスURLを設定します。     設定が完了しました。     メイン画面が表示されました。     ","permalink":"https://bokyung.dev/ja/2021/03/17/jenkins-install/","summary":"ローカル環境でJenkinsを試しましたが、エラーになるケールがあったため、検証のために、Amazon Linux2にJenkinsをインストールしてみました。\n構築するJenkinsの環境  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI名 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    EC2インスタンス作成及びJenkinsインストール EC2インスタンス作成ととセキュリティグループ設定   一番上に表示されているAMIを利用して作成しました。     Jenkinsアクセス用の8080ポートと、SSH接続用の22ポートを設定します。     Jenkinsインストール  Jenkins公式サイトのインストール方法 の順番通りに実行。  sudo wget -O /etc/yum.repos.d/jenkins.repo \\ https://pkg.jenkins.io/redhat-stable/jenkins.repo sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key sudo yum upgrade sudo yum install jenkins java-1.8.0-openjdk-devel.x86_64 sudo systemctl daemon-reload Jenkins 実行 sudo systemctl start jenkins サービス実行状態を確認し、active状態になっていることを確認します。   Jenkins 初期設定   Jenkinsへアクセスします。http://xxxxxxxxxx:8080/","title":"Amazon Linux2にJenkinsをインストールする"},{"content":"springboot + kotlinで開発したbackendAPIをCircleCIを利用してデプロイしています。 staging/production環境毎の環境変数はContextsを利用すればもっと簡単に設定することが可能です。\nContexts設定 Organization Settings \u0026gt; Contexts でサービスの各環境毎の環境変数を設定します。 staging/productionの環境名で追加しました。   staging環境の環境変数です。 ecrとecsのorbsを利用するため、AWSの環境変数を追加し、プロジェクト内で共通で利用するためにSERVICE_PREFIXを追加しました。   CircleCI config.yml 設定 build-and-push-image  backend-buildを実行します。 releaseブランチの場合、build-and-push-image-stagingを実行します。 masterブランチの場合、build-and-push-image-productionを実行します。 contextにはCircleCI Contextsで指定した名前を指定します。  version: 2.1 orbs: aws-ecr: circleci/aws-ecr@6.15.3 aws-ecs: circleci/aws-ecs@1.4.0 gradle: circleci/gradle@2.2.0 executors: openjdk-executor: docker: - image: circleci/openjdk:14-jdk-buster-node-browsers ..... jobs: backend-build: executor: openjdk-executor ..... workflows: build-deploy: jobs: - backend-build - aws-ecr/build-and-push-image: name: build-and-push-image-staging requires: - backend-build context: DEMO_STAGING attach-workspace: true checkout: false repo: \u0026#39;${SERVICE_PREFIX}\u0026#39; tag: \u0026#39;latest,${CIRCLE_SHA1}\u0026#39; filters: branches: only: - /release\\/.*/ - aws-ecr/build-and-push-image: name: build-and-push-image-production requires: - backend-build context: DEMO_PRODUCTION attach-workspace: true checkout: false repo: \u0026#39;${SERVICE_PREFIX}\u0026#39; tag: \u0026#39;latest,${CIRCLE_SHA1}\u0026#39; filters: branches: only: - master deploy-service-update  backend-buildを実行します。 releaseブランチの場合、build-and-push-image-stagingの実行が完了されたらdeploy-service-update-stagingを実行します。 masteブランチの場合、build-and-push-image-productionの実行が完了されたらbuild-and-push-image-productionを実行します。 contextにはCircleCI Contextsで指定した名前を指定します。  - aws-ecs/deploy-service-update: name: deploy-service-update-staging requires: - build-and-push-image-staging context: DEMO_STAGING family: \u0026#39;${SERVICE_PREFIX}-backend\u0026#39; cluster-name: \u0026#39;${SERVICE_PREFIX}-backend\u0026#39; service-name: \u0026#39;${SERVICE_PREFIX}-backend-ec2-service\u0026#39; container-image-name-updates: \u0026#39;container=${SERVICE_PREFIX}-backend,tag=${CIRCLE_SHA1}\u0026#39; filters: branches: only: - /release\\/.*/ - aws-ecs/deploy-service-update: name: deploy-service-update-production requires: - build-and-push-image-production context: DEMO_PRODUCTION family: \u0026#39;${SERVICE_PREFIX}-backend\u0026#39; cluster-name: \u0026#39;${SERVICE_PREFIX}-backend\u0026#39; service-name: \u0026#39;${SERVICE_PREFIX}-backend-ec2-service\u0026#39; container-image-name-updates: \u0026#39;container=${SERVICE_PREFIX}-backend,tag=${CIRCLE_SHA1}\u0026#39; filters: branches: only: - master CircleCI デプロイ release/20210202_1 ブランチを push   新たなタスク定義が登録されていることを確認 task-definition/*****-backend:5   AWS ECS 確認  タスク定義 demo1-backend:5でタスクが起動されていることが確認できます。     ","permalink":"https://bokyung.dev/ja/2021/02/02/clrcleci-ecs-deploy/","summary":"springboot + kotlinで開発したbackendAPIをCircleCIを利用してデプロイしています。 staging/production環境毎の環境変数はContextsを利用すればもっと簡単に設定することが可能です。\nContexts設定 Organization Settings \u0026gt; Contexts でサービスの各環境毎の環境変数を設定します。 staging/productionの環境名で追加しました。   staging環境の環境変数です。 ecrとecsのorbsを利用するため、AWSの環境変数を追加し、プロジェクト内で共通で利用するためにSERVICE_PREFIXを追加しました。   CircleCI config.yml 設定 build-and-push-image  backend-buildを実行します。 releaseブランチの場合、build-and-push-image-stagingを実行します。 masterブランチの場合、build-and-push-image-productionを実行します。 contextにはCircleCI Contextsで指定した名前を指定します。  version: 2.1 orbs: aws-ecr: circleci/aws-ecr@6.15.3 aws-ecs: circleci/aws-ecs@1.4.0 gradle: circleci/gradle@2.2.0 executors: openjdk-executor: docker: - image: circleci/openjdk:14-jdk-buster-node-browsers ..... jobs: backend-build: executor: openjdk-executor ..... workflows: build-deploy: jobs: - backend-build - aws-ecr/build-and-push-image: name: build-and-push-image-staging requires: - backend-build context: DEMO_STAGING attach-workspace: true checkout: false repo: \u0026#39;${SERVICE_PREFIX}\u0026#39; tag: \u0026#39;latest,${CIRCLE_SHA1}\u0026#39; filters: branches: only: - /release\\/.","title":"CircleCIのContextsを利用し、AWS ECSへデプロイする"}]