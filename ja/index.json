[{"content":"リサイズされた画像をS3へ保存せずに、原本のみ利用してリサイズさせる方法がないか調べてみましたが、Lambda@Edgeを利用してリサイズさせる方法があったので、試してみました。\nLambda@Edge動作概要    Lambda@EdgeはCloudFrontへアクセスする時に実行されるLambdaの拡張版です。 CloudFrontイベント発生時、Lambda関数の実行が可能です。 イベントには４種類があります。\n Viewer Request : CloudFrontがビューアーからのリクエストを受け、リクエストしたオブジェクトがedge cacheにあるかを確認する前に関数を実行します。 Origin Request : CloudFrontがオリジンにリクエストを渡す場合のみ実行されます。 リクエストしたオブジェクトがedge cacheにある場合は関数は実行されません。 Origin Response : CloudFrontがオリジンからレスポンスを受け取った後、レスポンスへオブジェクトをcacheする前に関数を実行します。 Viewer Response : リクエストしたオブジェクトをビューアーに返却する前に実行されます。 この関数は、オブジェクトがedge cacheに既に存在しているか否かに関わらず実行されます。  Lambda@Edge 注意点  環境変数は利用不可 us-east-1 リージョンのみ対応 イベントタイプによって異なるクォータ    Entity Origin request and response event quotas Viewer request and response event quotas     Function memory size Same as Lambda quotas（128 MB to 10,240 MB） 128 MB   Function timeout 30 seconds 5 seconds   Size of a response 1 MB 40 KB   Maximum compressed size of a Lambda function and any included libraries 50 MB 1 MB      イメージリサイジング処理実装 イメージリサイジング処理の流れ Origin Responseイベント発生時、Lambda@Edge関数を実行する方法を利用しました。\n https://images.example.com/images/heic_image.heic?w=1500\u0026amp;h=1500 へアクセス CloudFrontから画像データをリクエストしたが、cacheされてない状態。 CloudFrontがS3オリジンへリクエスト。 S3オリジンに画像が存在したら、S3オリジンから応答。 Lambda関数を実行し、画像をリサイジング。 リサイジング後の画像をCloudFrontへcache処理するようにリクエスト。 CloudFrontはcache処理後、ブラウザーにリサイズされた画像を表示。  CloudFront 設定 CloudFormationを利用して構築しました。DistributionConfigの設定の中で一部を見てみましょう。  Lambda@Edge IAM Role作成 Policy { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;VisualEditor0\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;cloudfront:UpdateDistribution\u0026#34;, \u0026#34;iam:CreateServiceLinkedRole\u0026#34;, \u0026#34;s3:GetObject\u0026#34;, \u0026#34;lambda:EnableReplication\u0026#34;, \u0026#34;lambda:GetFunction\u0026#34;, \u0026#34;logs:CreateLogGroup\u0026#34;, \u0026#34;logs:CreateLogStream\u0026#34;, \u0026#34;logs:PutLogEvents\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] } Trust Relationship Policy { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: [ \u0026#34;edgelambda.amazonaws.com\u0026#34;, \u0026#34;lambda.amazonaws.com\u0026#34; ] }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34; } ] } Lambda関数作成 Sharpリサイズ用のパッケージインストール npm install --arch=x64 --platform=linux sharp AWS Lambda用 Sharpインストールガイド \nindex.js作成  zipファイルアップロード index.js, node_modulesをzipファイルに圧縮し、Code source \u0026gt; Upload from .zip fileを選択して、ファイルをアップロードします。 RuntimeはNode.js 14.xを選びます。\n. ├── index.js ├── node_modules/ └── package.json Lambda@Edgeデプロイ Actions \u0026gt; Deploy to Lambda@Edgeをクリックし、Lambda@Edgeをデプロイします。   リサイズテスト 画像リサイズ heicをjpegへ変換して、リサイズされていることが確認できます。\ncurl -I \u0026#39;https://images.example.com/images/heic_image.heic?w=1400\u0026amp;h=1400\u0026#39; HTTP/2 200 content-type: image/jpeg content-length: 356013 date: Fri, 14 May 2021 01:50:28 GMT last-modified: Fri, 14 May 2021 01:37:54 GMT etag: \u0026#34;9835f7aa1198532d0b538axxxxxxxxxx\u0026#34; accept-ranges: bytes server: AmazonS3 x-cache: Miss from cloudfront via: 1.1 186a60433f9963bxxxxxxxxxxxxxx.cloudfront.net (CloudFront) x-amz-cf-pop: NRT20-C2 x-amz-cf-id: dihScCemgN8p_VVykjhmXZhkaRP1t7B_y0o_WZoJMK17hexhbHMU0g== 再度アクセスすると、cacheが適用されていることが確認できます。\ncurl -I 'https://images.example.com/images/heic_image.heic?w=1400\u0026amp;h=1400' HTTP/2 200 content-type: image/jpeg content-length: 356013 date: Fri, 14 May 2021 01:50:28 GMT last-modified: Fri, 14 May 2021 01:37:54 GMT etag: \u0026quot;9835f7aa1198532d0b538axxxxxxxxxx\u0026quot; accept-ranges: bytes server: AmazonS3 x-cache: Hit from cloudfront via: 1.1 65866bb6c20ad09xxxxxxxxxxxxxxx.cloudfront.net (CloudFront) x-amz-cf-pop: NRT57-C2 x-amz-cf-id: C_g2WMkGFgKPtOX87AZBI6J66WDBDARs0pN23DBJSdMam6mUHntFEA== age: 3 Cloudfront SignedURLを利用する場合  SignedURLを発行します。  aws cloudfront sign \\  --url https://images.example.com/images/heic_image.heic?w=1400\u0026amp;h=1400 \\  --key-pair-id K2XRXXXXXXXXXX \\  --private-key file:///\u0026lt;key path\u0026gt;/private_key.pem \\  --date-less-than 2021-05-14T10:50:00+09:00 \\  --profile \u0026lt;profile name\u0026gt; https://images.example.com/images/heic_image.heic?w=1400\u0026amp;h=1400\u0026amp;Expires=1620957000\u0026amp;Signature=NLDdoaOrD0S8hyEIBzH6Q0otJagaRmUUtX3ZY0uuA0QIzc1e5D6z-ddQ~k0U1~4WQSiK-sDGplt-CPDiUTjz053yFlaDWzQohNybLLVRcUaKRXDgl~ahJPwjfstnKzzOl4g3Z628ZD-8UkLPnPaUx~Ibeo2Z55GFp8Ih0aNBZuPdd0al~4X5~lUGrsgZvRfg0QWis1X3VvShWPLL3nIphAFtJJu0~IfzyKNRZMQMTBvJcqL-ifdA2uj99VHGz-pec7r33y38TW5sirS6kQVJHe9WmAxjDQhTO42M04oSHwu~t6Mrxh3~DalyxEM0wcQ5yWOAKD9FA4~A7im-9tbBTg__\u0026amp;Key-Pair-Id=K2XRXXXXXXXXXX  SignedURLへアクセスします。heicをjpegへ変換して、リサイズされていることが確認できます。  curl -I \u0026#39;https://images.example.com/images/heic_image.heic?w=1400\u0026amp;h=1400\u0026amp;Expires=1620957000\u0026amp;Signature=NLDdoaOrD0S8hyEIBzH6Q0otJagaRmUUtX3ZY0uuA0QIzc1e5D6z-ddQ~k0U1~4WQSiK-sDGplt-CPDiUTjz053yFlaDWzQohNybLLVRcUaKRXDgl~ahJPwjfstnKzzOl4g3Z628ZD-8UkLPnPaUx~Ibeo2Z55GFp8Ih0aNBZuPdd0al~4X5~lUGrsgZvRfg0QWis1X3VvShWPLL3nIphAFtJJu0~IfzyKNRZMQMTBvJcqL-ifdA2uj99VHGz-pec7r33y38TW5sirS6kQVJHe9WmAxjDQhTO42M04oSHwu~t6Mrxh3~DalyxEM0wcQ5yWOAKD9FA4~A7im-9tbBTg__\u0026amp;Key-Pair-Id=K2XRXXXXXXXXXX\u0026#39; HTTP/2 200 content-type: image/jpeg content-length: 356013 date: Fri, 14 May 2021 01:45:27 GMT last-modified: Fri, 14 May 2021 01:37:54 GMT etag: \u0026#34;9835f7aa1198532d0b538axxxxxxxxxx\u0026#34; accept-ranges: bytes server: AmazonS3 x-cache: Miss from cloudfront via: 1.1 25d5704e1dc4bae769b7dexxxxxxxxxx.cloudfront.net (CloudFront) x-amz-cf-pop: NRT57-C2 x-amz-cf-id: 1pJUhQFKbilToyrRCp4_IwkBec1ki3fh5G-Y0fltGoTeRA3WUsymPQ== 参考  https://sharp.pixelplumbing.com/install#aws-lambda  https://docs.aws.amazon.com/ja_jp/AmazonCloudFront/latest/DeveloperGuide/lambda-requirements-limits.html  https://aws.amazon.com/blogs/networking-and-content-delivery/resizing-images-with-amazon-cloudfront-lambdaedge-aws-cdn-blog/   ","permalink":"https://bokyung.dev/ja/2021/05/14/lambda-edge-resize/","summary":"リサイズされた画像をS3へ保存せずに、原本のみ利用してリサイズさせる方法がないか調べてみましたが、Lambda@Edgeを利用してリサイズさせる方法があったので、試してみました。\nLambda@Edge動作概要    Lambda@EdgeはCloudFrontへアクセスする時に実行されるLambdaの拡張版です。 CloudFrontイベント発生時、Lambda関数の実行が可能です。 イベントには４種類があります。\n Viewer Request : CloudFrontがビューアーからのリクエストを受け、リクエストしたオブジェクトがedge cacheにあるかを確認する前に関数を実行します。 Origin Request : CloudFrontがオリジンにリクエストを渡す場合のみ実行されます。 リクエストしたオブジェクトがedge cacheにある場合は関数は実行されません。 Origin Response : CloudFrontがオリジンからレスポンスを受け取った後、レスポンスへオブジェクトをcacheする前に関数を実行します。 Viewer Response : リクエストしたオブジェクトをビューアーに返却する前に実行されます。 この関数は、オブジェクトがedge cacheに既に存在しているか否かに関わらず実行されます。  Lambda@Edge 注意点  環境変数は利用不可 us-east-1 リージョンのみ対応 イベントタイプによって異なるクォータ    Entity Origin request and response event quotas Viewer request and response event quotas     Function memory size Same as Lambda quotas（128 MB to 10,240 MB） 128 MB   Function timeout 30 seconds 5 seconds   Size of a response 1 MB 40 KB   Maximum compressed size of a Lambda function and any included libraries 50 MB 1 MB      イメージリサイジング処理実装 イメージリサイジング処理の流れ Origin Responseイベント発生時、Lambda@Edge関数を実行する方法を利用しました。","title":"CloudFrontとLambda@Edgeを利用して画像をリサイズさせる。"},{"content":"公式サイト の見ながらreact.jsプロジェクトにSentryを適用してみました。\nバージョン  react 17.0.1 Sentry  @sentry/react 6.2.5 @sentry/tracing 6.2.5    Sentryへプロジェクト追加及び設定  Sentryへログイン後、プロジェクト作成。 Client Keys (DSN)メニューに書いてある、DSNキーをコピーしておきます。    sentry パッケージインストール npm install --save @sentry/react @sentry/tracing  index.jsにSentryを初期化するコードを追加します。 import React from \u0026quot;react\u0026quot;; import ReactDOM from \u0026quot;react-dom\u0026quot;; import * as Sentry from \u0026quot;@sentry/react\u0026quot;; import { Integrations } from \u0026quot;@sentry/tracing\u0026quot;; import App from \u0026quot;./App\u0026quot;; import \u0026quot;./index.css\u0026quot;; Sentry.init({ // 全ての環境に設定時 dsn: \u0026quot;https://xxxxxxxxxxxxxxxxxxxxxxxxxxx@xxxxxx.ingest.sentry.io/xxxxx\u0026quot;, // productionのみ設定時 dsn: process.env.NODE_ENV === \u0026quot;production\u0026quot; ? \u0026quot;https://xxxxxxxxxxxxxxxxxxxxxxxxxxx@xxxxxx.ingest.sentry.io/xxxxx\u0026quot; : false, integrations: [new Integrations.BrowserTracing()], environment: process.env.NODE_ENV, tracesSampleRate: 1.0, }); ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026quot;root\u0026quot;) );  Sentryへエラーを送るための設定  api実行時、エラーが発生したらsentryにエラーを送るように追加しました。 import * as Sentry from \u0026quot;@sentry/react\u0026quot;; ... ... useEffect(() =\u0026gt; { fetchPost(); },[]); const fetchPost = () =\u0026gt; { PostDataService.getPost(id) .then(response =\u0026gt; { setCurrentPost(response.data); }) .catch(e =\u0026gt; { Sentry.captureException(e); }); };     エラーを発生させ、Sentry側を確認  404エラーを発生させてみました。    Search by Traceをクリックするとエラートレースも可能です。    Dashboardも提供しています。カスタムDashboardはBusinessプランから使えるそうです。     利用したい機能は Teamプランでも十分に使えそうなので、公式ドキュメントの細かい部分を見てみたいと思います。\n","permalink":"https://bokyung.dev/ja/2021/04/16/sentry-react/","summary":"公式サイト の見ながらreact.jsプロジェクトにSentryを適用してみました。\nバージョン  react 17.0.1 Sentry  @sentry/react 6.2.5 @sentry/tracing 6.2.5    Sentryへプロジェクト追加及び設定  Sentryへログイン後、プロジェクト作成。 Client Keys (DSN)メニューに書いてある、DSNキーをコピーしておきます。    sentry パッケージインストール npm install --save @sentry/react @sentry/tracing  index.jsにSentryを初期化するコードを追加します。 import React from \u0026quot;react\u0026quot;; import ReactDOM from \u0026quot;react-dom\u0026quot;; import * as Sentry from \u0026quot;@sentry/react\u0026quot;; import { Integrations } from \u0026quot;@sentry/tracing\u0026quot;; import App from \u0026quot;./App\u0026quot;; import \u0026quot;./index.css\u0026quot;; Sentry.init({ // 全ての環境に設定時 dsn: \u0026quot;https://xxxxxxxxxxxxxxxxxxxxxxxxxxx@xxxxxx.ingest.sentry.io/xxxxx\u0026quot;, // productionのみ設定時 dsn: process.env.NODE_ENV === \u0026quot;production\u0026quot; ?","title":"Sentryをreact.jsプロジェクトへ適用する"},{"content":"Spring BootプロジェクトでFlywayを利用していますが、手動で作業しないといけないケースが出てきます。データが多いテーブルに手動でカラムを追加したり、indexを追加したりなどなど。 手動で作業した場合は誰がいつ作業したのかが管理できないため、履歴管理する方法がないかと思い、公式ドキュメントを読んでみました。 ignoreIgnoredMigrationsパラメーターを検証してみました。\nバージョン  Flyway  flyway-core 7.1.1   Spring Boot 2.4.1  テーブル追加しサーバー起動  sqlバージョンファイル追加  V1.0.0__Create_accounts.sql CREATE TABLE accounts ( user_id serial PRIMARY KEY, username VARCHAR ( 50 ) UNIQUE NOT NULL, password VARCHAR ( 50 ) NOT NULL, created_on TIMESTAMP NOT NULL );  V1.1.0__Modify_accounts.sql ALTER TABLE accounts ADD COLUMN last_login TIMESTAMP;    サーバー起動  サーバー起動時、DBへ正常的にSQL文が反映されました。 2021-04-15 11:06:14.196 INFO 7888 --- [ restartedMain] o.f.core.internal.command.DbValidate : Successfully validated 2 migrations (execution time 00:00.029s) 2021-04-15 11:06:14.209 INFO 7888 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Current version of schema \u0026quot;public\u0026quot;: \u0026lt;\u0026lt; Empty Schema \u0026gt;\u0026gt; 2021-04-15 11:06:14.218 INFO 7888 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Migrating schema \u0026quot;public\u0026quot; to version \u0026quot;1.0.0 - Create accounts\u0026quot; 2021-04-15 11:06:14.284 INFO 7888 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Migrating schema \u0026quot;public\u0026quot; to version \u0026quot;1.1.0 - Modify accounts\u0026quot; 2021-04-15 11:06:14.305 INFO 7888 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Successfully applied 2 migrations to schema \u0026quot;public\u0026quot; (execution time 00:00.104s)  flyway_schema_historyにV1.1.0まで反映されてういることが確認できます。    accountsテーブルにも変更されたカラムが反映されています。       手動でカラム変更しサーバー起動  手動でemailカラムを追加しサーバーを起動してみました。 ALTER TABLE accounts ADD COLUMN email VARCHAR ( 255 ) UNIQUE NOT NULL  accountsテーブルにも変更されたカラムが反映されています。この状態でサーバーを起動します。    データマイグレーションなしにサーバーが起動できました。 2021-04-15 11:02:38.735 INFO 30080 --- [ restartedMain] o.f.core.internal.command.DbValidate : Successfully validated 2 migrations (execution time 00:00.031s) 2021-04-15 11:02:38.749 INFO 30080 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Current version of schema \u0026quot;public\u0026quot;: 1.1.0 2021-04-15 11:02:38.750 INFO 30080 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Schema \u0026quot;public\u0026quot; is up to date. No migration necessary.   手動で作業したSQLをバージョン管理する  sqlバージョンファイル追加  V1.0.9__Modify_accounts.sql ALTER TABLE accounts ADD COLUMN email VARCHAR ( 255 ) UNIQUE NOT NULL    この状態でサーバーを起動すると当然ながらマイグレーション失敗してしまいます。 org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'flywayInitializer' defined in class path resource [org/springframework/boot/autoconfigure/flyway/FlywayAutoConfiguration$FlywayConfiguration.class]: Invocation of init method failed; nested exception is org.flywaydb.core.api.exception.FlywayValidateException: Validate failed: Migrations have failed validation at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1788) ~[spring-beans-5.3.2.jar:5.3.2] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:609) ~[spring-beans-5.3.2.jar:5.3.2]   ignoreIgnoredMigrations パラメータを利用する Flyway 公式 Document に色んなパラメータがありましたが、その中でignoreIgnoredMigrationsが目に入りました。 最新バージョンより前のバージョンファイルがあってもvalidate実行時、レポートされないと書かれています。\n application.propertiesに ignore-ignored-migrationsオプションをtrueに設定します。 spring.flyway.ignore-ignored-migrations=true  sqlバージョンファイル追加  V1.0.9__Modify_accounts.sql ALTER TABLE accounts ADD COLUMN email VARCHAR ( 255 ) UNIQUE NOT NULL    V1.0.9バージョンもカウントされ、データマイグレーションなしにサーバーが起動されました。 2021-04-15 11:26:09.613 INFO 20004 --- [ restartedMain] o.f.core.internal.command.DbValidate : Successfully validated 3 migrations (execution time 00:00.035s) 2021-04-15 11:26:09.626 INFO 20004 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Current version of schema \u0026quot;public\u0026quot;: 1.1.0 2021-04-15 11:26:09.628 INFO 20004 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Schema \u0026quot;public\u0026quot; is up to date. No migration necessary.   これからバージョン番号にルールを付け、手動で作業したファイルも管理していきます。\n","permalink":"https://bokyung.dev/ja/2021/04/15/flyway-springboot/","summary":"Spring BootプロジェクトでFlywayを利用していますが、手動で作業しないといけないケースが出てきます。データが多いテーブルに手動でカラムを追加したり、indexを追加したりなどなど。 手動で作業した場合は誰がいつ作業したのかが管理できないため、履歴管理する方法がないかと思い、公式ドキュメントを読んでみました。 ignoreIgnoredMigrationsパラメーターを検証してみました。\nバージョン  Flyway  flyway-core 7.1.1   Spring Boot 2.4.1  テーブル追加しサーバー起動  sqlバージョンファイル追加  V1.0.0__Create_accounts.sql CREATE TABLE accounts ( user_id serial PRIMARY KEY, username VARCHAR ( 50 ) UNIQUE NOT NULL, password VARCHAR ( 50 ) NOT NULL, created_on TIMESTAMP NOT NULL );  V1.1.0__Modify_accounts.sql ALTER TABLE accounts ADD COLUMN last_login TIMESTAMP;    サーバー起動  サーバー起動時、DBへ正常的にSQL文が反映されました。 2021-04-15 11:06:14.196 INFO 7888 --- [ restartedMain] o.","title":"Flyway 一部手動で作業する"},{"content":"react.jsへSentryを適用しようと思い、公式ドキュメントを見てみると対応言語の中にSpringBootがあったため、試してみました。\nバージョン  Spring Boot 2.4.1 Sentry  sentry-spring-boot-starter 4.3.0    Sentryへプロジェクト追加及び設定   Sentryへログイン後、プロジェクト作成。\n  Client Keys (DSN)メニューに書いてある、DSNキーをコピーしておきます。     build.gradle.ktsに依存関係を追加します。\n build.gradle.kts implementation(\u0026quot;io.sentry:sentry-spring-boot-starter:4.3.0\u0026quot;)     application.properties에 DSN (Data Source Name)を設定します。\n application.properties # DSN設定 sentry.dsn=https://xxxxxxxxxxxxxxxxxxxxxxxxxxx@xxxxxx.ingest.sentry.io/xxxxx # エラートレース設定 sentry.enable-tracing=true  application-development.properties # 各環境の設定も可能です。 sentry.environment=development     Sentryにエラーを送るための設定\n サンプルプロジェクトがRestApiプロジェクトなので、@RestControllerAdviceを利用して共通エラー処理を追加しました。 @RestControllerAdvice class SampleControllerAdvice { @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(MissingPathVariableException::class) fun handleMissingPathVariable(ex: MissingPathVariableException): Map\u0026lt;String, String\u0026gt; { Sentry.captureException(ex) val error: Map\u0026lt;String, String\u0026gt; = mapOf(\u0026quot;code\u0026quot; to \u0026quot;E0001\u0026quot;, \u0026quot;message\u0026quot; to \u0026quot;Parameter error\u0026quot;) return error } @ResponseStatus(HttpStatus.UNSUPPORTED_MEDIA_TYPE) @ExceptionHandler(HttpMediaTypeNotSupportedException::class) fun handleHttpMediaTypeNotSupported(ex: HttpMediaTypeNotSupportedException): Map\u0026lt;String, String\u0026gt; { Sentry.captureException(ex) val error: Map\u0026lt;String, String\u0026gt; = mapOf(\u0026quot;code\u0026quot; to \u0026quot;E0002\u0026quot;, \u0026quot;message\u0026quot; to \u0026quot;Unsupported Media Type\u0026quot;) return error } @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler(Exception::class) fun handleExceptions(ex: Exception): Map\u0026lt;String, String\u0026gt; { Sentry.captureException(ex) val error: Map\u0026lt;String, String\u0026gt; = mapOf(\u0026quot;code\u0026quot; to \u0026quot;E0003\u0026quot;, \u0026quot;message\u0026quot; to \u0026quot;Internal Server Error\u0026quot;) return error } }     エラーを発生させ、Sentry側を確認  Content typeを追加し、エラーを発生させてみました。    Search by Traceをクリックするとエラートレースも可能です。    Dashboardも提供しています。カスタムDashboardはBusinessプランから使えるそうです。     slackへ通知  slackとか他のサービスと連携するためには、Teamプランにする必要があります。slackへのメッセージ通知のみならsentryのWebHooksを利用すればDeveloper(無料)ブランでも利用可能です。     Businessプランの場合、Amazon SQSへデータ転送もできると書いてあるので、便利そうです。 後で 公式サイド をよく見てみます。\n","permalink":"https://bokyung.dev/ja/2021/04/15/sentry-springboot/","summary":"react.jsへSentryを適用しようと思い、公式ドキュメントを見てみると対応言語の中にSpringBootがあったため、試してみました。\nバージョン  Spring Boot 2.4.1 Sentry  sentry-spring-boot-starter 4.3.0    Sentryへプロジェクト追加及び設定   Sentryへログイン後、プロジェクト作成。\n  Client Keys (DSN)メニューに書いてある、DSNキーをコピーしておきます。     build.gradle.ktsに依存関係を追加します。\n build.gradle.kts implementation(\u0026quot;io.sentry:sentry-spring-boot-starter:4.3.0\u0026quot;)     application.properties에 DSN (Data Source Name)を設定します。\n application.properties # DSN設定 sentry.dsn=https://xxxxxxxxxxxxxxxxxxxxxxxxxxx@xxxxxx.ingest.sentry.io/xxxxx # エラートレース設定 sentry.enable-tracing=true  application-development.properties # 各環境の設定も可能です。 sentry.environment=development     Sentryにエラーを送るための設定\n サンプルプロジェクトがRestApiプロジェクトなので、@RestControllerAdviceを利用して共通エラー処理を追加しました。 @RestControllerAdvice class SampleControllerAdvice { @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(MissingPathVariableException::class) fun handleMissingPathVariable(ex: MissingPathVariableException): Map\u0026lt;String, String\u0026gt; { Sentry.","title":"SentryをSpringBootプロジェクトへ適用する"},{"content":"JenkinsでSpring Batch Jobを実行してみました。\nJenkinsの環境  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI名 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    環境変数とプラグイン設定   複数のJobを登録する場合は、各Jobに同じパラメータを設定することになりますが、環境変数に登録しておくと一括管理ができます。\n  Jobパラメーターに実行日を渡すために、timestamperプラグインを利用しました。     Manage Jenkins \u0026gt; System Configuration \u0026gt; Configure System \u0026gt; Global properties \u0026gt; Environment variablesでJob共通で利用している環境変数を設定します。     Batch Job登録  New Item \u0026gt; Freestyle projectを選び、JOBを登録します。     java -jar ${JAR_NAME} ${DB_HOST} ${DB_PORT} ${DB_NAME} ${DB_USER} ${DB_PASSWORD} \\ --spring.batch.job.names=${JOB_NAME} version=${BUILD_NUMBER} requestDate=${BUILD_TIMESTAMP} --spring.batch.job.enabled=true --spring.profiles.active=dev Batch Job実行  Jobを実行し、実行結果を確認します。  2021-03-31 13:09:56.358 INFO 3564 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path '' 2021-03-31 13:09:56.379 INFO 3564 --- [ main] c.e.sample.batch.BatchApplicationKt : Started BatchApplicationKt in 12.493 seconds (JVM running for 13.807) 2021-03-31 13:09:56.380 INFO 3564 --- [ main] o.s.b.a.b.JobLauncherApplicationRunner : Running default command line with: [version=17, requestDate=2021-03-31] 2021-03-31 13:09:56.516 INFO 3564 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=jpaJob]] launched with the following parameters: [{requestDate=2021-03-31, version=17}] 2021-03-31 13:09:56.600 INFO 3564 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [jpaPagingItemStep] 2021-03-31 13:09:57.071 INFO 3564 --- [ main] o.s.batch.core.step.AbstractStep : Step: [jpaPagingItemStep] executed in 471ms 2021-03-31 13:09:57.092 INFO 3564 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=jpaJob]] completed with the following parameters: [{requestDate=2021-03-31, version=17}] and the following status: [COMPLETED] in 521ms 2021-03-31 13:09:57.127 INFO 3564 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Shutting down ExecutorService 'applicationTaskExecutor' 2021-03-31 13:09:57.129 INFO 3564 --- [ main] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default' 2021-03-31 13:09:57.140 INFO 3564 --- [ main] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Shutdown initiated... 2021-03-31 13:09:57.155 INFO 3564 --- [ main] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Shutdown completed. Finished: SUCCESS BatchApplication.kt  Job実行終了し、applicationも終了させるための設定。  @EnableBatchProcessing @SpringBootApplication class BatchApplication fun main(args: Array\u0026lt;String\u0026gt;) { val context = runApplication\u0026lt;BatchApplication\u0026gt;(*args) val exitCode = SpringApplication.exit(context) System.exit(exitCode) } ","permalink":"https://bokyung.dev/ja/2021/03/31/jenkins-batch-job/","summary":"JenkinsでSpring Batch Jobを実行してみました。\nJenkinsの環境  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI名 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    環境変数とプラグイン設定   複数のJobを登録する場合は、各Jobに同じパラメータを設定することになりますが、環境変数に登録しておくと一括管理ができます。\n  Jobパラメーターに実行日を渡すために、timestamperプラグインを利用しました。     Manage Jenkins \u0026gt; System Configuration \u0026gt; Configure System \u0026gt; Global properties \u0026gt; Environment variablesでJob共通で利用している環境変数を設定します。     Batch Job登録  New Item \u0026gt; Freestyle projectを選び、JOBを登録します。     java -jar ${JAR_NAME} ${DB_HOST} ${DB_PORT} ${DB_NAME} ${DB_USER} ${DB_PASSWORD} \\ --spring.","title":"Jenkins環境でSpring Batch Jobを実行する"},{"content":"Spring BatchのJob Runnerを調査していましたが、その中でJenkinsでbatchプロジェクトをgradleビルドをしてみました。\nJenkinsの環境  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI名 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    認証情報登録 Github ID/PASSWORD認証方法   JenkinsでRepository関連作業ができるようにGithub上でPersonal access tokensを発行します。 ( Settings \u0026gt; Developer settings \u0026gt; Personal access tokens )     Manage Jenkins \u0026gt; Manage Credentials \u0026gt; domainにあるglobalをクリックします。     KindはUsername with passwordを選び、パスワード欄にはPersonal access tokens値を入力し認証情報を追加します。     Github SSH 認証方法   SSH鍵を作成します。       Githubプロジェクト設定のDeploy keysに公開鍵を追加します。     KindはSSH Username with private keyを選び、Private Key \u0026gt; Enter directlyに秘密鍵を追加します。     Gradle, JDK設定  プロジェクトで利用するGradleとJDKを Manage Jenkins \u0026gt; System Configuration \u0026gt; Global Tool Configurationにて設定します。一つのバージョンのみ設定した場合は、各JOBでデフォルトとして設定されます。複数のバージョンが登録されている場合は、JOB設定時バージョンを選べられます。     Job登録   New Item \u0026gt; Freestyle projectを選び、JOBを登録します。github access tokens認証の場合は、Repository URLに git@github.com:bokyung-kang/batch-testを入力しCredentialsはgithub認証を登録したUsernameを選択します。     ssh認証の場合はRepository URLに git@github.com:bokyung-kang/batch-testを入力しCredentialsはssh認証を登録したUsernameを選択します。     build script\nchmod +x gradlew # testを実行しないようにassembleを実行しました。 ./gradlew assemble # deploy-testへjarをコピー。 mkdir -p $JENKINS_HOME/workspace/deploy-test cp $WORKSPACE/build/libs/*.jar $JENKINS_HOME/workspace/deploy-test/.   Gradle Build  ビルドを実行し、Console Outputを見てみます。  [batch-test] $ /bin/sh -xe /tmp/jenkins568576160326820555.sh + chmod +x gradlew + ./gradlew assemble Starting a Gradle Daemon (subsequent builds will be faster) \u0026gt; Task :compileKotlin \u0026gt; Task :compileJava NO-SOURCE \u0026gt; Task :processResources \u0026gt; Task :classes \u0026gt; Task :bootJarMainClassName \u0026gt; Task :bootJar \u0026gt; Task :inspectClassesForKotlinIC \u0026gt; Task :jar SKIPPED \u0026gt; Task :assemble BUILD SUCCESSFUL in 33s 5 actionable tasks: 5 executed + mkdir -p /var/lib/jenkins/workspace/deploy-test + cp /var/lib/jenkins/workspace/batch-test/build/libs/batch-0.0.1-SNAPSHOT.jar /var/lib/jenkins/workspace/deploy-test/. Finished: SUCCESS  $JENKINS_HOME/workspace/deploy-test/にjarファイルがコピーされていることが確認できます。     ","permalink":"https://bokyung.dev/ja/2021/03/30/jenkins-gradle-build/","summary":"Spring BatchのJob Runnerを調査していましたが、その中でJenkinsでbatchプロジェクトをgradleビルドをしてみました。\nJenkinsの環境  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI名 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    認証情報登録 Github ID/PASSWORD認証方法   JenkinsでRepository関連作業ができるようにGithub上でPersonal access tokensを発行します。 ( Settings \u0026gt; Developer settings \u0026gt; Personal access tokens )     Manage Jenkins \u0026gt; Manage Credentials \u0026gt; domainにあるglobalをクリックします。     KindはUsername with passwordを選び、パスワード欄にはPersonal access tokens値を入力し認証情報を追加します。     Github SSH 認証方法   SSH鍵を作成します。       Githubプロジェクト設定のDeploy keysに公開鍵を追加します。     KindはSSH Username with private keyを選び、Private Key \u0026gt; Enter directlyに秘密鍵を追加します。     Gradle, JDK設定  プロジェクトで利用するGradleとJDKを Manage Jenkins \u0026gt; System Configuration \u0026gt; Global Tool Configurationにて設定します。一つのバージョンのみ設定した場合は、各JOBでデフォルトとして設定されます。複数のバージョンが登録されている場合は、JOB設定時バージョンを選べられます。     Job登録   New Item \u0026gt; Freestyle projectを選び、JOBを登録します。github access tokens認証の場合は、Repository URLに git@github.","title":"Jenkins環境でSpring BatchプロジェクトをGradleビルドする"},{"content":"ローカル環境でJenkinsを試しましたが、エラーになるケールがあったため、検証のために、Amazon Linux2にJenkinsをインストールしてみました。\n構築するJenkinsの環境  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI名 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    EC2インスタンス作成及びJenkinsインストール EC2インスタンス作成ととセキュリティグループ設定   一番上に表示されているAMIを利用して作成しました。     Jenkinsアクセス用の8080ポートと、SSH接続用の22ポートを設定します。     Jenkinsインストール  Jenkins公式サイトのインストール方法 の順番通りに実行。  sudo wget -O /etc/yum.repos.d/jenkins.repo \\ https://pkg.jenkins.io/redhat-stable/jenkins.repo sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key sudo yum upgrade sudo yum install jenkins java-1.8.0-openjdk-devel.x86_64 sudo systemctl daemon-reload Jenkins 実行 sudo systemctl start jenkins サービス実行状態を確認し、active状態になっていることを確認します。   Jenkins 初期設定   Jenkinsへアクセスします。http://xxxxxxxxxx:8080/\n  初期パスワードを入力します。     プラグインをインストールします。     初期ユーザーを登録します。     インスタンスURLを設定します。     設定が完了しました。     メイン画面が表示されました。     ","permalink":"https://bokyung.dev/ja/2021/03/17/jenkins-install/","summary":"ローカル環境でJenkinsを試しましたが、エラーになるケールがあったため、検証のために、Amazon Linux2にJenkinsをインストールしてみました。\n構築するJenkinsの環境  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI名 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    EC2インスタンス作成及びJenkinsインストール EC2インスタンス作成ととセキュリティグループ設定   一番上に表示されているAMIを利用して作成しました。     Jenkinsアクセス用の8080ポートと、SSH接続用の22ポートを設定します。     Jenkinsインストール  Jenkins公式サイトのインストール方法 の順番通りに実行。  sudo wget -O /etc/yum.repos.d/jenkins.repo \\ https://pkg.jenkins.io/redhat-stable/jenkins.repo sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key sudo yum upgrade sudo yum install jenkins java-1.8.0-openjdk-devel.x86_64 sudo systemctl daemon-reload Jenkins 実行 sudo systemctl start jenkins サービス実行状態を確認し、active状態になっていることを確認します。   Jenkins 初期設定   Jenkinsへアクセスします。http://xxxxxxxxxx:8080/","title":"Amazon Linux2にJenkinsをインストールする"},{"content":"springboot + kotlinで開発したbackendAPIをCircleCIを利用してデプロイしています。 staging/production環境毎の環境変数はContextsを利用すればもっと簡単に設定することが可能です。\nContexts設定 Organization Settings \u0026gt; Contexts でサービスの各環境毎の環境変数を設定します。 staging/productionの環境名で追加しました。   staging環境の環境変数です。 ecrとecsのorbsを利用するため、AWSの環境変数を追加し、プロジェクト内で共通で利用するためにSERVICE_PREFIXを追加しました。   CircleCI config.yml 設定 build-and-push-image  backend-buildを実行します。 releaseブランチの場合、build-and-push-image-stagingを実行します。 masterブランチの場合、build-and-push-image-productionを実行します。 contextにはCircleCI Contextsで指定した名前を指定します。  version: 2.1 orbs: aws-ecr: circleci/aws-ecr@6.15.3 aws-ecs: circleci/aws-ecs@1.4.0 gradle: circleci/gradle@2.2.0 executors: openjdk-executor: docker: - image: circleci/openjdk:14-jdk-buster-node-browsers ..... jobs: backend-build: executor: openjdk-executor ..... workflows: build-deploy: jobs: - backend-build - aws-ecr/build-and-push-image: name: build-and-push-image-staging requires: - backend-build context: DEMO_STAGING attach-workspace: true checkout: false repo: \u0026#39;${SERVICE_PREFIX}\u0026#39; tag: \u0026#39;latest,${CIRCLE_SHA1}\u0026#39; filters: branches: only: - /release\\/.*/ - aws-ecr/build-and-push-image: name: build-and-push-image-production requires: - backend-build context: DEMO_PRODUCTION attach-workspace: true checkout: false repo: \u0026#39;${SERVICE_PREFIX}\u0026#39; tag: \u0026#39;latest,${CIRCLE_SHA1}\u0026#39; filters: branches: only: - master deploy-service-update  backend-buildを実行します。 releaseブランチの場合、build-and-push-image-stagingの実行が完了されたらdeploy-service-update-stagingを実行します。 masteブランチの場合、build-and-push-image-productionの実行が完了されたらbuild-and-push-image-productionを実行します。 contextにはCircleCI Contextsで指定した名前を指定します。  - aws-ecs/deploy-service-update: name: deploy-service-update-staging requires: - build-and-push-image-staging context: DEMO_STAGING family: \u0026#39;${SERVICE_PREFIX}-backend\u0026#39; cluster-name: \u0026#39;${SERVICE_PREFIX}-backend\u0026#39; service-name: \u0026#39;${SERVICE_PREFIX}-backend-ec2-service\u0026#39; container-image-name-updates: \u0026#39;container=${SERVICE_PREFIX}-backend,tag=${CIRCLE_SHA1}\u0026#39; filters: branches: only: - /release\\/.*/ - aws-ecs/deploy-service-update: name: deploy-service-update-production requires: - build-and-push-image-production context: DEMO_PRODUCTION family: \u0026#39;${SERVICE_PREFIX}-backend\u0026#39; cluster-name: \u0026#39;${SERVICE_PREFIX}-backend\u0026#39; service-name: \u0026#39;${SERVICE_PREFIX}-backend-ec2-service\u0026#39; container-image-name-updates: \u0026#39;container=${SERVICE_PREFIX}-backend,tag=${CIRCLE_SHA1}\u0026#39; filters: branches: only: - master CircleCI デプロイ release/20210202_1 ブランチを push   新たなタスク定義が登録されていることを確認 task-definition/*****-backend:5   AWS ECS 確認  タスク定義 demo1-backend:5でタスクが起動されていることが確認できます。     ","permalink":"https://bokyung.dev/ja/2021/02/02/clrcleci-ecs-deploy/","summary":"springboot + kotlinで開発したbackendAPIをCircleCIを利用してデプロイしています。 staging/production環境毎の環境変数はContextsを利用すればもっと簡単に設定することが可能です。\nContexts設定 Organization Settings \u0026gt; Contexts でサービスの各環境毎の環境変数を設定します。 staging/productionの環境名で追加しました。   staging環境の環境変数です。 ecrとecsのorbsを利用するため、AWSの環境変数を追加し、プロジェクト内で共通で利用するためにSERVICE_PREFIXを追加しました。   CircleCI config.yml 設定 build-and-push-image  backend-buildを実行します。 releaseブランチの場合、build-and-push-image-stagingを実行します。 masterブランチの場合、build-and-push-image-productionを実行します。 contextにはCircleCI Contextsで指定した名前を指定します。  version: 2.1 orbs: aws-ecr: circleci/aws-ecr@6.15.3 aws-ecs: circleci/aws-ecs@1.4.0 gradle: circleci/gradle@2.2.0 executors: openjdk-executor: docker: - image: circleci/openjdk:14-jdk-buster-node-browsers ..... jobs: backend-build: executor: openjdk-executor ..... workflows: build-deploy: jobs: - backend-build - aws-ecr/build-and-push-image: name: build-and-push-image-staging requires: - backend-build context: DEMO_STAGING attach-workspace: true checkout: false repo: \u0026#39;${SERVICE_PREFIX}\u0026#39; tag: \u0026#39;latest,${CIRCLE_SHA1}\u0026#39; filters: branches: only: - /release\\/.","title":"CircleCIのContextsを利用し、AWS ECSへデプロイする"}]