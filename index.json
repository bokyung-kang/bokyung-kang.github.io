[{"content":"이전 글에서 CloudFront와 Lambda@Edge를 이용해서 이미지 리사이징하기 를 정리해 보았는데요. AWS SAM을 이용해서 CloudFormation으로 Lambda함수를 배포하는 방법을 정리해 보았습니다.\n배포순서 SAM CLI설치 Install SAM CLI \n저는 SAM CLI, version 1.23.0을 이용했습니다\ntemplate.yaml작성 CloudFormation기반의 템플릿(template.yaml)을 작성합니다.\n. ├── index.js ├── node_modules/ ├── template.yaml ├── package-lock.json └── package.json  SAM deploy을 이용하여 코드 패키징과 배포 SAM deploy \\  --template-file template.yaml \\  # Lambda@edge인 경우는 us-east-1리전에 만든 Bucket이 필요합니다. --s3-bucket \u0026lt;zip파일을 업로드 할 Bucket name\u0026gt; \\  --s3-prefix SAM \\  --stack-name \u0026lt;cloudformation 스택명\u0026gt; \\  --capabilities CAPABILITY_NAMED_IAM \\  --region \u0026lt;cloudformation을 배포 할 리전\u0026gt; \\  --profile \u0026lt;profile name\u0026gt; SAM은 배포 시\n 애플리케이션의 코드를 압축해서 S3에 업로드 CodeUri가 S3 path로 변경된 CloudFormation 템플릿파일 생성, S3에 업로드 S3에 업로드된 파일을 이용해서 Cloudformation 스택을 생성하여 배포  Cloudformation 콘솔에서 Template를 확인하시거나 S3에 업로드된 Template를 다운받아서 열어 보시면 Code Uri에 S3를 지정하고 있는 것을 확인 할 수 있습니다.\nCodeUri: s3://\u0026lt;zip파일을 업로드 할 Bucket name\u0026gt;/SAM/70b53b458e040c19f27aaf1d7f197e0e Cloudformation 스택생성이 완료되면 Outputs에 람다함수의 새로 배포된 Version정보를 포함한 ARN정보를 표시해줍니다.\n이 ARN을 Cloudfront의 리사이징용 Behaviors \u0026gt; Edge Function Associations \u0026gt; Function ARN/Name에 넣어주었습니다.\n참고  https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#awsserverlessfunction](https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#awsserverlessfunction)  ","permalink":"https://bokyung.dev/2021/05/17/lambda-sam-deploy/","summary":"이전 글에서 CloudFront와 Lambda@Edge를 이용해서 이미지 리사이징하기 를 정리해 보았는데요. AWS SAM을 이용해서 CloudFormation으로 Lambda함수를 배포하는 방법을 정리해 보았습니다.\n배포순서 SAM CLI설치 Install SAM CLI \n저는 SAM CLI, version 1.23.0을 이용했습니다\ntemplate.yaml작성 CloudFormation기반의 템플릿(template.yaml)을 작성합니다.\n. ├── index.js ├── node_modules/ ├── template.yaml ├── package-lock.json └── package.json  SAM deploy을 이용하여 코드 패키징과 배포 SAM deploy \\  --template-file template.yaml \\  # Lambda@edge인 경우는 us-east-1리전에 만든 Bucket이 필요합니다. --s3-bucket \u0026lt;zip파일을 업로드 할 Bucket name\u0026gt; \\  --s3-prefix SAM \\  --stack-name \u0026lt;cloudformation 스택명\u0026gt; \\  --capabilities CAPABILITY_NAMED_IAM \\  --region \u0026lt;cloudformation을 배포 할 리전\u0026gt; \\  --profile \u0026lt;profile name\u0026gt; SAM은 배포 시","title":"AWS SAM을 이용해서 Lambda함수 배포하기"},{"content":"리사이징 된 이미지를 S3에 저장하지 않고 원본만 이용해서 리사이징 하는 방법은 없을까 고민하던차에 Lambda@Edge를 이용해서 이미지 리사이징 하는 방법을 적용해 보았습니다.\nLambda@Edge 동작 원리    Lambda@Edge는 CloudFront에 접근할 때 실행되는 Lambda의 확장판입니다. CloudFront 이벤트가 발생할 때 Lambda 함수를 실행할 수 있습니다. 이벤트는 4가지가 있습니다.\n Viewer Request : CloudFront가 뷰어로부터 요청을 받고 요청한 개체가 edge cache에 있는지 확인하기 전에 함수를 실행합니다. Origin Request : CloudFront가 오리진으로 요청을 전달할 때만 실행됩니다. 요청한 개체가 edge cache에 있으면 함수가 실행되지 않습니다. Origin Response : CloudFront가 오리진으로부터 응답을 받은 후 응답에 개체를 cache하기 전에 함수를 실행합니다. Viewer Response : 요청한 개체를 뷰어에 반환하기 전에 기능이 실행됩니다. 이 함수는 개체가 edge cache에 이미 있는지 여부에 관계없이 실행됩니다.  Lambda@Edge 주의점  환경변수는 사용 불가 us-east-1 리전만 대응 이벤트 유형에 따라 다른 할당량    Entity Origin request and response event quotas Viewer request and response event quotas     Function memory size Same as Lambda quotas（128 MB to 10,240 MB） 128 MB   Function timeout 30 seconds 5 seconds   Size of a response 1 MB 40 KB   Maximum compressed size of a Lambda function and any included libraries 50 MB 1 MB      이미지 리사이징 구현 이미지 리사이징 처리 흐름 Origin Response이벤트 발생 시, Lambda@Edge함수 실행하는 방법을 이용했습니다.\n https://images.example.com/images/heic_image.heic?w=1500\u0026amp;h=1500 에 접속 CloudFront에서 이미지를 요청했지만, cache되어있지 않은 상태. CloudFront가 S3오리진에 요청. S3오리진에 이미지가 존재하면, S3오리진에서 응답. Lambda 함수를 실행하여 이미지 리사이징. 리사이징 한 이미지를 CloudFront에 캐싱처리 요청. CloudFront는 캐싱 후, 브라우저에 리사이징 된 이미지를 표시.  CloudFront 설정 CloudFormation을 이용해서 구축했습니다. DistributionConfig 설정 중 일부를 살펴보겠습니다.  Lambda@Edge IAM Role 작성 Policy { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;VisualEditor0\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;cloudfront:UpdateDistribution\u0026#34;, \u0026#34;iam:CreateServiceLinkedRole\u0026#34;, \u0026#34;s3:GetObject\u0026#34;, \u0026#34;lambda:EnableReplication\u0026#34;, \u0026#34;lambda:GetFunction\u0026#34;, \u0026#34;logs:CreateLogGroup\u0026#34;, \u0026#34;logs:CreateLogStream\u0026#34;, \u0026#34;logs:PutLogEvents\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] } Trust Relationship Policy { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: [ \u0026#34;edgelambda.amazonaws.com\u0026#34;, \u0026#34;lambda.amazonaws.com\u0026#34; ] }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34; } ] } Lambda 함수 작성 Sharp 리사이징용 패키지 설치 npm install --arch=x64 --platform=linux sharp AWS Lambda용 Sharp 설치 가이드 \nindex.js 작성  zip파일 업로드 index.js, node_modules을 zip파일로 압축하고 Code source \u0026gt; Upload from .zip file을 선택해서 파일을 업로드합니다. Runtime은 Node.js 14.x를 선택합니다.\n. ├── index.js ├── node_modules/ └── package.json Lambda@Edge 배포 Actions \u0026gt; Deploy to Lambda@Edge를 클릭하고 Lambda@Edge를 배포합니다.   리사이징 테스트 이미지 리사이징 heic파일을 jpeg로 변경하여 리사이징에 성공한 것을 확인할 수 있습니다.\ncurl -I \u0026#39;https://images.example.com/images/heic_image.heic?w=1400\u0026amp;h=1400\u0026#39; HTTP/2 200 content-type: image/jpeg content-length: 356013 date: Fri, 14 May 2021 01:50:28 GMT last-modified: Fri, 14 May 2021 01:37:54 GMT etag: \u0026#34;9835f7aa1198532d0b538axxxxxxxxxx\u0026#34; accept-ranges: bytes server: AmazonS3 x-cache: Miss from cloudfront via: 1.1 186a60433f9963bxxxxxxxxxxxxxx.cloudfront.net (CloudFront) x-amz-cf-pop: NRT20-C2 x-amz-cf-id: dihScCemgN8p_VVykjhmXZhkaRP1t7B_y0o_WZoJMK17hexhbHMU0g== 다시 접속하면 cache가 적용된 것을 확인할 수 있습니다.\ncurl -I 'https://images.example.com/images/heic_image.heic?w=1400\u0026amp;h=1400' HTTP/2 200 content-type: image/jpeg content-length: 356013 date: Fri, 14 May 2021 01:50:28 GMT last-modified: Fri, 14 May 2021 01:37:54 GMT etag: \u0026quot;9835f7aa1198532d0b538axxxxxxxxxx\u0026quot; accept-ranges: bytes server: AmazonS3 x-cache: Hit from cloudfront via: 1.1 65866bb6c20ad09xxxxxxxxxxxxxxx.cloudfront.net (CloudFront) x-amz-cf-pop: NRT57-C2 x-amz-cf-id: C_g2WMkGFgKPtOX87AZBI6J66WDBDARs0pN23DBJSdMam6mUHntFEA== age: 3 Cloudfront SignedURL을 사용하는 경우  SignedURL을 발행합니다.  aws cloudfront sign \\  --url https://images.example.com/images/heic_image.heic?w=1400\u0026amp;h=1400 \\  --key-pair-id K2XRXXXXXXXXXX \\  --private-key file:///\u0026lt;key path\u0026gt;/private_key.pem \\  --date-less-than 2021-05-14T10:50:00+09:00 \\  --profile \u0026lt;profile name\u0026gt; https://images.example.com/images/heic_image.heic?w=1400\u0026amp;h=1400\u0026amp;Expires=1620957000\u0026amp;Signature=NLDdoaOrD0S8hyEIBzH6Q0otJagaRmUUtX3ZY0uuA0QIzc1e5D6z-ddQ~k0U1~4WQSiK-sDGplt-CPDiUTjz053yFlaDWzQohNybLLVRcUaKRXDgl~ahJPwjfstnKzzOl4g3Z628ZD-8UkLPnPaUx~Ibeo2Z55GFp8Ih0aNBZuPdd0al~4X5~lUGrsgZvRfg0QWis1X3VvShWPLL3nIphAFtJJu0~IfzyKNRZMQMTBvJcqL-ifdA2uj99VHGz-pec7r33y38TW5sirS6kQVJHe9WmAxjDQhTO42M04oSHwu~t6Mrxh3~DalyxEM0wcQ5yWOAKD9FA4~A7im-9tbBTg__\u0026amp;Key-Pair-Id=K2XRXXXXXXXXXX  SignedURL에 접속 해 봅니다. heic파일을 jpeg로 변경하여 리사이징에 성공한 것을 확인할 수 있습니다.  curl -I \u0026#39;https://images.example.com/images/heic_image.heic?w=1400\u0026amp;h=1400\u0026amp;Expires=1620957000\u0026amp;Signature=NLDdoaOrD0S8hyEIBzH6Q0otJagaRmUUtX3ZY0uuA0QIzc1e5D6z-ddQ~k0U1~4WQSiK-sDGplt-CPDiUTjz053yFlaDWzQohNybLLVRcUaKRXDgl~ahJPwjfstnKzzOl4g3Z628ZD-8UkLPnPaUx~Ibeo2Z55GFp8Ih0aNBZuPdd0al~4X5~lUGrsgZvRfg0QWis1X3VvShWPLL3nIphAFtJJu0~IfzyKNRZMQMTBvJcqL-ifdA2uj99VHGz-pec7r33y38TW5sirS6kQVJHe9WmAxjDQhTO42M04oSHwu~t6Mrxh3~DalyxEM0wcQ5yWOAKD9FA4~A7im-9tbBTg__\u0026amp;Key-Pair-Id=K2XRXXXXXXXXXX\u0026#39; HTTP/2 200 content-type: image/jpeg content-length: 356013 date: Fri, 14 May 2021 01:45:27 GMT last-modified: Fri, 14 May 2021 01:37:54 GMT etag: \u0026#34;9835f7aa1198532d0b538axxxxxxxxxx\u0026#34; accept-ranges: bytes server: AmazonS3 x-cache: Miss from cloudfront via: 1.1 25d5704e1dc4bae769b7dexxxxxxxxxx.cloudfront.net (CloudFront) x-amz-cf-pop: NRT57-C2 x-amz-cf-id: 1pJUhQFKbilToyrRCp4_IwkBec1ki3fh5G-Y0fltGoTeRA3WUsymPQ== 참고  https://sharp.pixelplumbing.com/install#aws-lambda  https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/lambda-requirements-limits.html  https://aws.amazon.com/blogs/networking-and-content-delivery/resizing-images-with-amazon-cloudfront-lambdaedge-aws-cdn-blog/   ","permalink":"https://bokyung.dev/2021/05/14/lambda-edge-resize/","summary":"리사이징 된 이미지를 S3에 저장하지 않고 원본만 이용해서 리사이징 하는 방법은 없을까 고민하던차에 Lambda@Edge를 이용해서 이미지 리사이징 하는 방법을 적용해 보았습니다.\nLambda@Edge 동작 원리    Lambda@Edge는 CloudFront에 접근할 때 실행되는 Lambda의 확장판입니다. CloudFront 이벤트가 발생할 때 Lambda 함수를 실행할 수 있습니다. 이벤트는 4가지가 있습니다.\n Viewer Request : CloudFront가 뷰어로부터 요청을 받고 요청한 개체가 edge cache에 있는지 확인하기 전에 함수를 실행합니다. Origin Request : CloudFront가 오리진으로 요청을 전달할 때만 실행됩니다.","title":"CloudFront와 Lambda@Edge를 이용해서 이미지 리사이징하기"},{"content":"공식사이트 를 보면서 react.js에 Sentry를 적용해 보았습니다.\n버전  react 17.0.1 Sentry  @sentry/react 6.2.5 @sentry/tracing 6.2.5    Sentry에 프로젝트 추가 및 설정   Sentry에 로그인 후 프로젝트를 생성합니다.\n  Client Keys (DSN)메뉴에 있는 DSN키를 복사해둡니다.     sentry 패키지 인스톨\nnpm install --save @sentry/react @sentry/tracing   index.js에 Sentry를 초기화해주는 코드를 추가합니다.\nimport React from \u0026quot;react\u0026quot;; import ReactDOM from \u0026quot;react-dom\u0026quot;; import * as Sentry from \u0026quot;@sentry/react\u0026quot;; import { Integrations } from \u0026quot;@sentry/tracing\u0026quot;; import App from \u0026quot;./App\u0026quot;; import \u0026quot;./index.css\u0026quot;; Sentry.init({ // 모든환경에 설정할 경우 dsn: \u0026quot;https://xxxxxxxxxxxxxxxxxxxxxxxxxxx@xxxxxx.ingest.sentry.io/xxxxx\u0026quot;, // production환경만 설정할 경우 dsn: process.env.NODE_ENV === \u0026quot;production\u0026quot; ? \u0026quot;https://xxxxxxxxxxxxxxxxxxxxxxxxxxx@xxxxxx.ingest.sentry.io/xxxxx\u0026quot; : false, integrations: [new Integrations.BrowserTracing()], environment: process.env.NODE_ENV, tracesSampleRate: 1.0, }); ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026quot;root\u0026quot;) );   Sentry에 에러를 보내기 위한 설정\n api실행 중 에러가 발생하면 sentry에 에러를 보내도록 추가했습니다. import * as Sentry from \u0026quot;@sentry/react\u0026quot;; ... ... useEffect(() =\u0026gt; { fetchPost(); },[]); const fetchPost = () =\u0026gt; { PostDataService.getPost(id) .then(response =\u0026gt; { setCurrentPost(response.data); }) .catch(e =\u0026gt; { Sentry.captureException(e); }); };     에러를 발생시켜 Sentry상세페이지 확인  404에러를 발생시켜보겠습니다.    Search by Trace를 클릭하면 에러 추척도 가능하네요.    Dashboard도 제공하네요.　Custom Dashboards는 Business플랜부터 가능하네요.     사용하고 싶은 기능은 Team플랜으로도 충분해서 공식문서를 좀 더 살펴봐야겠습니다.\n","permalink":"https://bokyung.dev/2021/04/16/sentry-react/","summary":"공식사이트 를 보면서 react.js에 Sentry를 적용해 보았습니다.\n버전  react 17.0.1 Sentry  @sentry/react 6.2.5 @sentry/tracing 6.2.5    Sentry에 프로젝트 추가 및 설정   Sentry에 로그인 후 프로젝트를 생성합니다.\n  Client Keys (DSN)메뉴에 있는 DSN키를 복사해둡니다.     sentry 패키지 인스톨\nnpm install --save @sentry/react @sentry/tracing   index.js에 Sentry를 초기화해주는 코드를 추가합니다.\nimport React from \u0026quot;react\u0026quot;; import ReactDOM from \u0026quot;react-dom\u0026quot;; import * as Sentry from \u0026quot;@sentry/react\u0026quot;; import { Integrations } from \u0026quot;@sentry/tracing\u0026quot;; import App from \u0026quot;.","title":"Sentry를 리액트 프로젝트에 적용하기"},{"content":"스프링부트 프로젝트에서 Flyway를 사용하다 보면 수동으로 작업을 해야 하는 경우가 생깁니다. 데이터가 많은 테이블에 수동으로 컬럼이나 인덱스를 추가한다던가. 그런데 이렇게 되면 누가 수동으로 작업을 했는지 이력이 남지 않기때문에 이력관리도 할 수 있는 방법이 없을까하고 공식 Document를 찾아봤습니다. ignoreIgnoredMigrations파라미터를 테스트해 보았습니다.\n버전  Flyway  flyway-core 7.1.1   Spring Boot 2.4.1  테이블 추가, 서버 기동  sql버전 파일 추가  V1.0.0__Create_accounts.sql CREATE TABLE accounts ( user_id serial PRIMARY KEY, username VARCHAR ( 50 ) UNIQUE NOT NULL, password VARCHAR ( 50 ) NOT NULL, created_on TIMESTAMP NOT NULL );  V1.1.0__Modify_accounts.sql ALTER TABLE accounts ADD COLUMN last_login TIMESTAMP;    서버기동  서버 기동 시 DB에 정상적으로 SQL문이 반영되었습니다. 2021-04-15 11:06:14.196 INFO 7888 --- [ restartedMain] o.f.core.internal.command.DbValidate : Successfully validated 2 migrations (execution time 00:00.029s) 2021-04-15 11:06:14.209 INFO 7888 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Current version of schema \u0026quot;public\u0026quot;: \u0026lt;\u0026lt; Empty Schema \u0026gt;\u0026gt; 2021-04-15 11:06:14.218 INFO 7888 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Migrating schema \u0026quot;public\u0026quot; to version \u0026quot;1.0.0 - Create accounts\u0026quot; 2021-04-15 11:06:14.284 INFO 7888 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Migrating schema \u0026quot;public\u0026quot; to version \u0026quot;1.1.0 - Modify accounts\u0026quot; 2021-04-15 11:06:14.305 INFO 7888 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Successfully applied 2 migrations to schema \u0026quot;public\u0026quot; (execution time 00:00.104s)  flyway_schema_history에 V1.1.0까지 잘 반영되어있는것을 확인할 수 있습니다.    accounts테이블에도 변경된 컬럼이 반영되어 있습니다.       수동으로 컬럼 변경, 서버 기동  수동으로 email컬럼을 추가 후에 서버를 기동해보겠습니다. ALTER TABLE accounts ADD COLUMN email VARCHAR ( 255 ) UNIQUE NOT NULL  accounts테이블에도 변경된 컬럼이 반영되어 있습니다. 이 상태로 서버를 기동해보겠습니다.    데이터 마이그레이션없이 서버가 잘 기동되었네요. 2021-04-15 11:02:38.735 INFO 30080 --- [ restartedMain] o.f.core.internal.command.DbValidate : Successfully validated 2 migrations (execution time 00:00.031s) 2021-04-15 11:02:38.749 INFO 30080 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Current version of schema \u0026quot;public\u0026quot;: 1.1.0 2021-04-15 11:02:38.750 INFO 30080 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Schema \u0026quot;public\u0026quot; is up to date. No migration necessary.   수동작업 한 SQL을 버전관리하기  sql버전 파일 추가  V1.0.9__Modify_accounts.sql ALTER TABLE accounts ADD COLUMN email VARCHAR ( 255 ) UNIQUE NOT NULL    이 상태로 서버를 실행하면 당연히 마이그레이션 실패를 합니다. org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'flywayInitializer' defined in class path resource [org/springframework/boot/autoconfigure/flyway/FlywayAutoConfiguration$FlywayConfiguration.class]: Invocation of init method failed; nested exception is org.flywaydb.core.api.exception.FlywayValidateException: Validate failed: Migrations have failed validation at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1788) ~[spring-beans-5.3.2.jar:5.3.2] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:609) ~[spring-beans-5.3.2.jar:5.3.2]   ignoreIgnoredMigrations 파라미터 이용하기 공식 Document 에 여러 파라미터가 있는데 그중에 ignoreIgnoredMigrations파라미터가 눈에 들어왔습니다. 최신 버전보다 이전 버전의 파일이 있어도 validate실행시 레포트 되지 않는다고 나와 있네요.\n application.properties에 ignore-ignored-migrations옵션을 true로 설정해줍니다. spring.flyway.ignore-ignored-migrations=true  sql버전 파일 추가  V1.0.9__Modify_accounts.sql ALTER TABLE accounts ADD COLUMN email VARCHAR ( 255 ) UNIQUE NOT NULL    V1.0.9버전도 카운트되어 마이그레이션없이 서버가 잘 기동되었네요. 2021-04-15 11:26:09.613 INFO 20004 --- [ restartedMain] o.f.core.internal.command.DbValidate : Successfully validated 3 migrations (execution time 00:00.035s) 2021-04-15 11:26:09.626 INFO 20004 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Current version of schema \u0026quot;public\u0026quot;: 1.1.0 2021-04-15 11:26:09.628 INFO 20004 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Schema \u0026quot;public\u0026quot; is up to date. No migration necessary.   앞으로 버전번호에 룰을 정해서 수동적용 한 파일들은 관리해야겠습니다.\n","permalink":"https://bokyung.dev/2021/04/15/flyway-springboot/","summary":"스프링부트 프로젝트에서 Flyway를 사용하다 보면 수동으로 작업을 해야 하는 경우가 생깁니다. 데이터가 많은 테이블에 수동으로 컬럼이나 인덱스를 추가한다던가. 그런데 이렇게 되면 누가 수동으로 작업을 했는지 이력이 남지 않기때문에 이력관리도 할 수 있는 방법이 없을까하고 공식 Document를 찾아봤습니다. ignoreIgnoredMigrations파라미터를 테스트해 보았습니다.\n버전  Flyway  flyway-core 7.1.1   Spring Boot 2.4.1  테이블 추가, 서버 기동  sql버전 파일 추가  V1.0.0__Create_accounts.sql CREATE TABLE accounts ( user_id serial PRIMARY KEY, username VARCHAR ( 50 ) UNIQUE NOT NULL, password VARCHAR ( 50 ) NOT NULL, created_on TIMESTAMP NOT NULL );  V1.","title":"Flyway 일부 수동으로 작업하기"},{"content":"react.js에 Sentry를 적용하려고 찾아보던 중에 스프링부트도 대응언어에 포함되어있어서 테스트해 보았습니다.\n버전  Spring Boot 2.4.1 Sentry  sentry-spring-boot-starter 4.3.0    Sentry에 프로젝트 추가 및 설정   Sentry에 로그인 후 프로젝트를 생성합니다.\n  Client Keys (DSN)메뉴에 있는 DSN키를 복사해둡니다.     build.gradle.kts에 의존관계를 추가합니다.\n build.gradle.kts implementation(\u0026quot;io.sentry:sentry-spring-boot-starter:4.3.0\u0026quot;)     application.properties에 DSN (Data Source Name)을 설정합니다.\n application.properties # DSN설정 sentry.dsn=https://xxxxxxxxxxxxxxxxxxxxxxxxxxx@xxxxxx.ingest.sentry.io/xxxxx # 에러 추척 설정 sentry.enable-tracing=true  application-development.properties # 각각의 환경도 설정할 수 있습니다. sentry.environment=development     Sentry에 에러를 보내기 위한 설정\n RestApi프로젝트라 @RestControllerAdvice을 이용하여 공통 예외 처리를 추가했습니다. @RestControllerAdvice class SampleControllerAdvice { @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(MissingPathVariableException::class) fun handleMissingPathVariable(ex: MissingPathVariableException): Map\u0026lt;String, String\u0026gt; { Sentry.captureException(ex) val error: Map\u0026lt;String, String\u0026gt; = mapOf(\u0026quot;code\u0026quot; to \u0026quot;E0001\u0026quot;, \u0026quot;message\u0026quot; to \u0026quot;Parameter error\u0026quot;) return error } @ResponseStatus(HttpStatus.UNSUPPORTED_MEDIA_TYPE) @ExceptionHandler(HttpMediaTypeNotSupportedException::class) fun handleHttpMediaTypeNotSupported(ex: HttpMediaTypeNotSupportedException): Map\u0026lt;String, String\u0026gt; { Sentry.captureException(ex) val error: Map\u0026lt;String, String\u0026gt; = mapOf(\u0026quot;code\u0026quot; to \u0026quot;E0002\u0026quot;, \u0026quot;message\u0026quot; to \u0026quot;Unsupported Media Type\u0026quot;) return error } @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler(Exception::class) fun handleExceptions(ex: Exception): Map\u0026lt;String, String\u0026gt; { Sentry.captureException(ex) val error: Map\u0026lt;String, String\u0026gt; = mapOf(\u0026quot;code\u0026quot; to \u0026quot;E0003\u0026quot;, \u0026quot;message\u0026quot; to \u0026quot;Internal Server Error\u0026quot;) return error } }     에러를 발생시켜 Sentry상세페이지 확인  Content type을 추가해서 에러를 발생시켜보겠습니다.    Search by Trace를 클릭하면 에러 추척도 가능하네요.    Dashboard도 제공하네요.　Custom Dashboards는 Business플랜부터 가능하네요.     slack에 통지  slack이나 타 서비스와 연계하려면 Team플랜부터 가능하네요. slack에 메세지만 통지하는 용도라면 sentry의 WebHooks를 이용하면 Developer(무료)플랜으로도 사용가능합니다.     Business플랜이면 Amazon SQS에 데이터 전송도 가능하다니 편리할 것 같습니다. 나중에 공식사이트 를 꼼꼼히 살펴보아야겠습니다.\n","permalink":"https://bokyung.dev/2021/04/15/sentry-springboot/","summary":"react.js에 Sentry를 적용하려고 찾아보던 중에 스프링부트도 대응언어에 포함되어있어서 테스트해 보았습니다.\n버전  Spring Boot 2.4.1 Sentry  sentry-spring-boot-starter 4.3.0    Sentry에 프로젝트 추가 및 설정   Sentry에 로그인 후 프로젝트를 생성합니다.\n  Client Keys (DSN)메뉴에 있는 DSN키를 복사해둡니다.     build.gradle.kts에 의존관계를 추가합니다.\n build.gradle.kts implementation(\u0026quot;io.sentry:sentry-spring-boot-starter:4.3.0\u0026quot;)     application.properties에 DSN (Data Source Name)을 설정합니다.\n application.properties # DSN설정 sentry.dsn=https://xxxxxxxxxxxxxxxxxxxxxxxxxxx@xxxxxx.ingest.sentry.io/xxxxx # 에러 추척 설정 sentry.","title":"Sentry를 스프링부트 프로젝트에 적용하기"},{"content":"Jenkins에서 스프링 배치 Job을 실행해 보았습니다.\nJenkins 환경  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI 이름 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    환경변수와 플러그인 설정   여러 Job을 등록하는 경우 각각의 Job에서 같은 파라미터를 넘겨주게 되는데 환경변수에 등록해두면 관리하기가 편해집니다.\n  Job파라미터로 실행날짜를 넘겨주기 위해서 timestamper플러그인을 사용하였습니다.     Manage Jenkins \u0026gt; System Configuration \u0026gt; Configure System \u0026gt; Global properties \u0026gt; Environment variables에서 Job에서 공통으로 사용하는 환경변수를 설정합니다.     배치Job등록  New Item \u0026gt; Freestyle project을 선택해서 Job을 등록합니다.     java -jar ${JAR_NAME} ${DB_HOST} ${DB_PORT} ${DB_NAME} ${DB_USER} ${DB_PASSWORD} \\ --spring.batch.job.names=${JOB_NAME} version=${BUILD_NUMBER} requestDate=${BUILD_TIMESTAMP} --spring.batch.job.enabled=true --spring.profiles.active=dev 배치Job실행  Job을 실행하고 실행 결과를 확인합니다.  2021-03-31 13:09:56.358 INFO 3564 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path '' 2021-03-31 13:09:56.379 INFO 3564 --- [ main] c.e.sample.batch.BatchApplicationKt : Started BatchApplicationKt in 12.493 seconds (JVM running for 13.807) 2021-03-31 13:09:56.380 INFO 3564 --- [ main] o.s.b.a.b.JobLauncherApplicationRunner : Running default command line with: [version=17, requestDate=2021-03-31] 2021-03-31 13:09:56.516 INFO 3564 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=jpaJob]] launched with the following parameters: [{requestDate=2021-03-31, version=17}] 2021-03-31 13:09:56.600 INFO 3564 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [jpaPagingItemStep] 2021-03-31 13:09:57.071 INFO 3564 --- [ main] o.s.batch.core.step.AbstractStep : Step: [jpaPagingItemStep] executed in 471ms 2021-03-31 13:09:57.092 INFO 3564 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=jpaJob]] completed with the following parameters: [{requestDate=2021-03-31, version=17}] and the following status: [COMPLETED] in 521ms 2021-03-31 13:09:57.127 INFO 3564 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Shutting down ExecutorService 'applicationTaskExecutor' 2021-03-31 13:09:57.129 INFO 3564 --- [ main] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default' 2021-03-31 13:09:57.140 INFO 3564 --- [ main] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Shutdown initiated... 2021-03-31 13:09:57.155 INFO 3564 --- [ main] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Shutdown completed. Finished: SUCCESS BatchApplication.kt  Job실행 종료시 application도 종료시키기 위한 설정  @EnableBatchProcessing @SpringBootApplication class BatchApplication fun main(args: Array\u0026lt;String\u0026gt;) { val context = runApplication\u0026lt;BatchApplication\u0026gt;(*args) val exitCode = SpringApplication.exit(context) System.exit(exitCode) } ","permalink":"https://bokyung.dev/2021/03/31/jenkins-batch-job/","summary":"Jenkins에서 스프링 배치 Job을 실행해 보았습니다.\nJenkins 환경  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI 이름 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    환경변수와 플러그인 설정   여러 Job을 등록하는 경우 각각의 Job에서 같은 파라미터를 넘겨주게 되는데 환경변수에 등록해두면 관리하기가 편해집니다.\n  Job파라미터로 실행날짜를 넘겨주기 위해서 timestamper플러그인을 사용하였습니다.     Manage Jenkins \u0026gt; System Configuration \u0026gt; Configure System \u0026gt; Global properties \u0026gt; Environment variables에서 Job에서 공통으로 사용하는 환경변수를 설정합니다.","title":"Jenkins에서 Spring Batch Job을 실행하기"},{"content":"스프링 배치 Job Runner를 조사하던 중에 Jenkins에서 batch프로젝트를 gradle빌드해 보았습니다.\nJenkins 환경  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI 이름 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    인증정보 등록 Github 아이디/패스워드 인증 방법   Jenkins에서 Repository관련 작업이 가능하도록 Github에서 Personal access tokens를 발행합니다. ( Settings \u0026gt; Developer settings \u0026gt; Personal access tokens )     Manage Jenkins \u0026gt; Manage Credentials \u0026gt; domain에 있는 global을 클릭합니다.     Kind는 Username with password를 선택하고 패스워드란에 Personal access tokens값을 입력하고 인증정보를 추가합니다.     Github SSH 인증 방법   SSH키를 생성합니다.       Github 프로젝트 설정에서 Deploy keys에 공개키를 추가합니다.     Kind는 SSH Username with private key를 선택하고 Private Key \u0026gt; Enter directly 에 비밀키를 추가합니다.     Gradle, JDK설정  프로젝트에서 사용할 Gradle과 JDK를 Manage Jenkins \u0026gt; System Configuration \u0026gt; Global Tool Configuration에서 설정합니다. 한가지 버전만 설정한 경우 각 JOB에서 디폴트로 설정됩니다. 복수개 버전이 등록된 경우에는 JOB설정시 버전선택이 가능합니다.     Job등록   New Item \u0026gt; Freestyle project을 선택해서 Job을 등록합니다. github access tokens으로 인증할 경우에는 Repository URL에 git@github.com:bokyung-kang/batch-test을 입력하고 Credentials에서 github인증을 등록한 Username을 선택합니다.     ssh인증할 경우에는 Repository URL에 git@github.com:bokyung-kang/batch-test을 입력하고 Credentials에서 ssh을 등록한 Username을 선택합니다.     build script\nchmod +x gradlew # test를 실행안하려고 저는 assemble을 실행했습니다 ./gradlew assemble # deploy-test에 jar복사 mkdir -p $JENKINS_HOME/workspace/deploy-test cp $WORKSPACE/build/libs/*.jar $JENKINS_HOME/workspace/deploy-test/.   Gradle Build  빌드를 실행합니다.  [batch-test] $ /bin/sh -xe /tmp/jenkins568576160326820555.sh + chmod +x gradlew + ./gradlew assemble Starting a Gradle Daemon (subsequent builds will be faster) \u0026gt; Task :compileKotlin \u0026gt; Task :compileJava NO-SOURCE \u0026gt; Task :processResources \u0026gt; Task :classes \u0026gt; Task :bootJarMainClassName \u0026gt; Task :bootJar \u0026gt; Task :inspectClassesForKotlinIC \u0026gt; Task :jar SKIPPED \u0026gt; Task :assemble BUILD SUCCESSFUL in 33s 5 actionable tasks: 5 executed + mkdir -p /var/lib/jenkins/workspace/deploy-test + cp /var/lib/jenkins/workspace/batch-test/build/libs/batch-0.0.1-SNAPSHOT.jar /var/lib/jenkins/workspace/deploy-test/. Finished: SUCCESS  $JENKINS_HOME/workspace/deploy-test/에 jar파일이 복사되었네요.     ","permalink":"https://bokyung.dev/2021/03/30/jenkins-gradle-build/","summary":"스프링 배치 Job Runner를 조사하던 중에 Jenkins에서 batch프로젝트를 gradle빌드해 보았습니다.\nJenkins 환경  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI 이름 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    인증정보 등록 Github 아이디/패스워드 인증 방법   Jenkins에서 Repository관련 작업이 가능하도록 Github에서 Personal access tokens를 발행합니다. ( Settings \u0026gt; Developer settings \u0026gt; Personal access tokens )     Manage Jenkins \u0026gt; Manage Credentials \u0026gt; domain에 있는 global을 클릭합니다.","title":"Jenkins에서 Spring Batch 프로젝트를 Gradle 빌드하기"},{"content":"로컬 도커환경에서 Jenkins를 테스트 하던 중에 에러가 나는 경우가 있어서 검증을 위해서 Amazon Linux2에 Jenkins를 설치 해 보았습니다.\n설치한 Jenkins 환경  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI 이름 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    EC2 인스턴스 생성 및 Jenkins설치 EC2 인스턴스 생성 및 보안그룹 설정   맨위에 표시되는 AMI로 생성했습니다.     젠킨스 접속용 8080포트와 SSH접속용 22번 포트를 설정합니다.     Jenkins 설치  Jenkins 공홈 설치 방법 에 나와있는 순서대로 설치하였습니다.  sudo wget -O /etc/yum.repos.d/jenkins.repo \\ https://pkg.jenkins.io/redhat-stable/jenkins.repo sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key sudo yum upgrade sudo yum install jenkins java-1.8.0-openjdk-devel.x86_64 sudo systemctl daemon-reload Jenkins 실행 sudo systemctl start jenkins 서비스 실행 상태를 확인하여, active상태인 것을 확인합니다.   Jenkins 초기 설정   Jenkins에 접속합니다. http://xxxxxxxxxx:8080/\n  초기패스워드를 화면에 입력합니다.     추천플러그인을 설치합니다.     초기유저를 등록합니다.     인스턴스 접속주소를 등록합니다.     설정이 완료되었습니다.     메인화면이 표시되었습니다.     ","permalink":"https://bokyung.dev/2021/03/17/jenkins-install/","summary":"로컬 도커환경에서 Jenkins를 테스트 하던 중에 에러가 나는 경우가 있어서 검증을 위해서 Amazon Linux2에 Jenkins를 설치 해 보았습니다.\n설치한 Jenkins 환경  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI 이름 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    EC2 인스턴스 생성 및 Jenkins설치 EC2 인스턴스 생성 및 보안그룹 설정   맨위에 표시되는 AMI로 생성했습니다.     젠킨스 접속용 8080포트와 SSH접속용 22번 포트를 설정합니다.","title":"Amazon Linux2에 Jenkins 설치하기"},{"content":"springboot + kotlin으로 개발한 backendAPI를 CircleCI로 배포하고 있습니다. staging/production 환경별 환경변수를 Contexts를 이용하면 좀 더 편리하게 설정할 수 있습니다.\nContexts 설정 Organization Settings \u0026gt; Contexts 에서 서비스의 각 환경별 환경변수를 설정합니다. staging/production 환경 이름으로 등록했습니다.   staging 환경의 환경변수입니다. ecr와 ecs용 orbs를 이용하기 위해서 AWS 환경변수를 추가하고 프로젝트에서 공통으로 사용하기 위해서 SERVICE_PREFIX를 추가했습니다.   CircleCI config.yml 설정 build-and-push-image  backend-build를 실행합니다. release 브랜치인 경우 build-and-push-image-staging을 실행합니다. master 브랜치인 경우 build-and-push-image-production을 실행합니다. context에는 CircleCI Contexts에서 지정한 이름을 추가합니다.  version: 2.1 orbs: aws-ecr: circleci/aws-ecr@6.15.3 aws-ecs: circleci/aws-ecs@1.4.0 gradle: circleci/gradle@2.2.0 executors: openjdk-executor: docker: - image: circleci/openjdk:14-jdk-buster-node-browsers ..... jobs: backend-build: executor: openjdk-executor ..... workflows: build-deploy: jobs: - backend-build - aws-ecr/build-and-push-image: name: build-and-push-image-staging requires: - backend-build context: DEMO_STAGING attach-workspace: true checkout: false repo: \u0026#39;${SERVICE_PREFIX}\u0026#39; tag: \u0026#39;latest,${CIRCLE_SHA1}\u0026#39; filters: branches: only: - /release\\/.*/ - aws-ecr/build-and-push-image: name: build-and-push-image-production requires: - backend-build context: DEMO_PRODUCTION attach-workspace: true checkout: false repo: \u0026#39;${SERVICE_PREFIX}\u0026#39; tag: \u0026#39;latest,${CIRCLE_SHA1}\u0026#39; filters: branches: only: - master deploy-service-update  backend-build를 실행합니다. release 브랜치인 경우 build-and-push-image-staging의 실행이 완료되면 deploy-service-update-staging을 실행합니다. master 브랜치인 경우 build-and-push-image-production의 실행이 완료되면 build-and-push-image-production을 실행합니다. context에는 CircleCI Contexts에서 지정한 이름을 추가합니다.  - aws-ecs/deploy-service-update: name: deploy-service-update-staging requires: - build-and-push-image-staging context: DEMO_STAGING family: \u0026#39;${SERVICE_PREFIX}-backend\u0026#39; cluster-name: \u0026#39;${SERVICE_PREFIX}-backend\u0026#39; service-name: \u0026#39;${SERVICE_PREFIX}-backend-ec2-service\u0026#39; container-image-name-updates: \u0026#39;container=${SERVICE_PREFIX}-backend,tag=${CIRCLE_SHA1}\u0026#39; filters: branches: only: - /release\\/.*/ - aws-ecs/deploy-service-update: name: deploy-service-update-production requires: - build-and-push-image-production context: DEMO_PRODUCTION family: \u0026#39;${SERVICE_PREFIX}-backend\u0026#39; cluster-name: \u0026#39;${SERVICE_PREFIX}-backend\u0026#39; service-name: \u0026#39;${SERVICE_PREFIX}-backend-ec2-service\u0026#39; container-image-name-updates: \u0026#39;container=${SERVICE_PREFIX}-backend,tag=${CIRCLE_SHA1}\u0026#39; filters: branches: only: - master CircleCI 배포 release/20210202_1 브랜치를 push   새 작업정의가 등록된것을 확인 task-definition/*****-backend:5   AWS ECS 확인  작업정의 demo1-backend:5로 작업이 기동된 것을 확인할 수 있습니다.     ","permalink":"https://bokyung.dev/2021/02/02/clrcleci-ecs-deploy/","summary":"springboot + kotlin으로 개발한 backendAPI를 CircleCI로 배포하고 있습니다. staging/production 환경별 환경변수를 Contexts를 이용하면 좀 더 편리하게 설정할 수 있습니다.\nContexts 설정 Organization Settings \u0026gt; Contexts 에서 서비스의 각 환경별 환경변수를 설정합니다. staging/production 환경 이름으로 등록했습니다.   staging 환경의 환경변수입니다. ecr와 ecs용 orbs를 이용하기 위해서 AWS 환경변수를 추가하고 프로젝트에서 공통으로 사용하기 위해서 SERVICE_PREFIX를 추가했습니다.   CircleCI config.yml 설정 build-and-push-image  backend-build를 실행합니다. release 브랜치인 경우 build-and-push-image-staging을 실행합니다. master 브랜치인 경우 build-and-push-image-production을 실행합니다.","title":"CircleCI의 Contexts를 이용하여 AWS ECS 자동 배포하기"}]