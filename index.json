[{"content":"공식사이트 를 보면서 react.js에 Sentry를 적용해 보았습니다.\n버전  react 17.0.1 Sentry  @sentry/react 6.2.5 @sentry/tracing 6.2.5       (adsbygoogle = window.adsbygoogle || []).push({});  Sentry에 프로젝트 추가 및 설정   Sentry에 로그인 후 프로젝트를 생성합니다.\n  Client Keys (DSN)메뉴에 있는 DSN키를 복사해둡니다.     sentry 패키지 인스톨\nnpm install --save @sentry/react @sentry/tracing   index.js에 Sentry를 초기화해주는 코드를 추가합니다.\nimport React from \u0026quot;react\u0026quot;; import ReactDOM from \u0026quot;react-dom\u0026quot;; import * as Sentry from \u0026quot;@sentry/react\u0026quot;; import { Integrations } from \u0026quot;@sentry/tracing\u0026quot;; import App from \u0026quot;./App\u0026quot;; import \u0026quot;./index.css\u0026quot;; Sentry.init({ // 모든환경에 설정할 경우 dsn: \u0026quot;https://xxxxxxxxxxxxxxxxxxxxxxxxxxx@xxxxxx.ingest.sentry.io/xxxxx\u0026quot;, // production환경만 설정할 경우 dsn: process.env.NODE_ENV === \u0026quot;production\u0026quot; ? \u0026quot;https://xxxxxxxxxxxxxxxxxxxxxxxxxxx@xxxxxx.ingest.sentry.io/xxxxx\u0026quot; : false, integrations: [new Integrations.BrowserTracing()], environment: process.env.NODE_ENV, tracesSampleRate: 1.0, }); ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026quot;root\u0026quot;) );   Sentry에 에러를 보내기 위한 설정\n api실행 중 에러가 발생하면 sentry에 에러를 보내도록 추가했습니다. import * as Sentry from \u0026quot;@sentry/react\u0026quot;; ... ... useEffect(() =\u0026gt; { fetchPost(); },[]); const fetchPost = () =\u0026gt; { PostDataService.getPost(id) .then(response =\u0026gt; { setCurrentPost(response.data); }) .catch(e =\u0026gt; { Sentry.captureException(e); }); };        (adsbygoogle = window.adsbygoogle || []).push({});  에러를 발생시켜 Sentry상세페이지 확인  404에러를 발생시켜보겠습니다.    Search by Trace를 클릭하면 에러 추척도 가능하네요.    Dashboard도 제공하네요.　Custom Dashboards는 Business플랜부터 가능하네요.     사용하고 싶은 기능은 Team플랜으로도 충분해서 공식문서를 좀 더 살펴봐야겠습니다.\n","permalink":"https://bokyung.dev/2021/04/16/sentry-react/","summary":"공식사이트 를 보면서 react.js에 Sentry를 적용해 보았습니다.\n버전  react 17.0.1 Sentry  @sentry/react 6.2.5 @sentry/tracing 6.2.5       (adsbygoogle = window.adsbygoogle || []).push({});  Sentry에 프로젝트 추가 및 설정   Sentry에 로그인 후 프로젝트를 생성합니다.\n  Client Keys (DSN)메뉴에 있는 DSN키를 복사해둡니다.     sentry 패키지 인스톨\nnpm install --save @sentry/react @sentry/tracing   index.js에 Sentry를 초기화해주는 코드를 추가합니다.\nimport React from \u0026quot;react\u0026quot;; import ReactDOM from \u0026quot;react-dom\u0026quot;; import * as Sentry from \u0026quot;@sentry/react\u0026quot;; import { Integrations } from \u0026quot;@sentry/tracing\u0026quot;; import App from \u0026quot;.","title":"Sentry를 리액트 프로젝트에 적용하기"},{"content":"스프링부트 프로젝트에서 Flyway를 사용하다 보면 수동으로 작업을 해야 하는 경우가 생깁니다. 데이터가 많은 테이블에 수동으로 컬럼이나 인덱스를 추가한다던가. 그런데 이렇게 되면 누가 수동으로 작업을 했는지 이력이 남지 않기때문에 이력관리도 할 수 있는 방법이 없을까하고 공식 Document를 찾아봤습니다. ignoreIgnoredMigrations파라미터를 테스트해 보았습니다.\n버전  Flyway  flyway-core 7.1.1   Spring Boot 2.4.1  테이블 추가, 서버 기동  sql버전 파일 추가  V1.0.0__Create_accounts.sql CREATE TABLE accounts ( user_id serial PRIMARY KEY, username VARCHAR ( 50 ) UNIQUE NOT NULL, password VARCHAR ( 50 ) NOT NULL, created_on TIMESTAMP NOT NULL );  V1.1.0__Modify_accounts.sql ALTER TABLE accounts ADD COLUMN last_login TIMESTAMP;    서버기동  서버 기동 시 DB에 정상적으로 SQL문이 반영되었습니다. 2021-04-15 11:06:14.196 INFO 7888 --- [ restartedMain] o.f.core.internal.command.DbValidate : Successfully validated 2 migrations (execution time 00:00.029s) 2021-04-15 11:06:14.209 INFO 7888 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Current version of schema \u0026quot;public\u0026quot;: \u0026lt;\u0026lt; Empty Schema \u0026gt;\u0026gt; 2021-04-15 11:06:14.218 INFO 7888 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Migrating schema \u0026quot;public\u0026quot; to version \u0026quot;1.0.0 - Create accounts\u0026quot; 2021-04-15 11:06:14.284 INFO 7888 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Migrating schema \u0026quot;public\u0026quot; to version \u0026quot;1.1.0 - Modify accounts\u0026quot; 2021-04-15 11:06:14.305 INFO 7888 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Successfully applied 2 migrations to schema \u0026quot;public\u0026quot; (execution time 00:00.104s)  flyway_schema_history에 V1.1.0까지 잘 반영되어있는것을 확인할 수 있습니다.    accounts테이블에도 변경된 컬럼이 반영되어 있습니다.       수동으로 컬럼 변경, 서버 기동  수동으로 email컬럼을 추가 후에 서버를 기동해보겠습니다. ALTER TABLE accounts ADD COLUMN email VARCHAR ( 255 ) UNIQUE NOT NULL  accounts테이블에도 변경된 컬럼이 반영되어 있습니다. 이 상태로 서버를 기동해보겠습니다.    데이터 마이그레이션없이 서버가 잘 기동되었네요. 2021-04-15 11:02:38.735 INFO 30080 --- [ restartedMain] o.f.core.internal.command.DbValidate : Successfully validated 2 migrations (execution time 00:00.031s) 2021-04-15 11:02:38.749 INFO 30080 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Current version of schema \u0026quot;public\u0026quot;: 1.1.0 2021-04-15 11:02:38.750 INFO 30080 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Schema \u0026quot;public\u0026quot; is up to date. No migration necessary.   수동작업 한 SQL을 버전관리하기  sql버전 파일 추가  V1.0.9__Modify_accounts.sql ALTER TABLE accounts ADD COLUMN email VARCHAR ( 255 ) UNIQUE NOT NULL    이 상태로 서버를 실행하면 당연히 마이그레이션 실패를 합니다. org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'flywayInitializer' defined in class path resource [org/springframework/boot/autoconfigure/flyway/FlywayAutoConfiguration$FlywayConfiguration.class]: Invocation of init method failed; nested exception is org.flywaydb.core.api.exception.FlywayValidateException: Validate failed: Migrations have failed validation at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1788) ~[spring-beans-5.3.2.jar:5.3.2] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:609) ~[spring-beans-5.3.2.jar:5.3.2]   ignoreIgnoredMigrations 파라미터 이용하기 공식 Document 에 여러 파라미터가 있는데 그중에 ignoreIgnoredMigrations파라미터가 눈에 들어왔습니다. 최신 버전보다 이전 버전의 파일이 있어도 validate실행시 레포트 되지 않는다고 나와 있네요.\n application.properties에 ignore-ignored-migrations옵션을 true로 설정해줍니다. spring.flyway.ignore-ignored-migrations=true  sql버전 파일 추가  V1.0.9__Modify_accounts.sql ALTER TABLE accounts ADD COLUMN email VARCHAR ( 255 ) UNIQUE NOT NULL    V1.0.9버전도 카운트되어 마이그레이션없이 서버가 잘 기동되었네요. 2021-04-15 11:26:09.613 INFO 20004 --- [ restartedMain] o.f.core.internal.command.DbValidate : Successfully validated 3 migrations (execution time 00:00.035s) 2021-04-15 11:26:09.626 INFO 20004 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Current version of schema \u0026quot;public\u0026quot;: 1.1.0 2021-04-15 11:26:09.628 INFO 20004 --- [ restartedMain] o.f.core.internal.command.DbMigrate : Schema \u0026quot;public\u0026quot; is up to date. No migration necessary.   앞으로 버전번호에 룰을 정해서 수동적용 한 파일들은 관리해야겠습니다.\n","permalink":"https://bokyung.dev/2021/04/15/flyway-springboot/","summary":"스프링부트 프로젝트에서 Flyway를 사용하다 보면 수동으로 작업을 해야 하는 경우가 생깁니다. 데이터가 많은 테이블에 수동으로 컬럼이나 인덱스를 추가한다던가. 그런데 이렇게 되면 누가 수동으로 작업을 했는지 이력이 남지 않기때문에 이력관리도 할 수 있는 방법이 없을까하고 공식 Document를 찾아봤습니다. ignoreIgnoredMigrations파라미터를 테스트해 보았습니다.\n버전  Flyway  flyway-core 7.1.1   Spring Boot 2.4.1  테이블 추가, 서버 기동  sql버전 파일 추가  V1.0.0__Create_accounts.sql CREATE TABLE accounts ( user_id serial PRIMARY KEY, username VARCHAR ( 50 ) UNIQUE NOT NULL, password VARCHAR ( 50 ) NOT NULL, created_on TIMESTAMP NOT NULL );  V1.","title":"Flyway 일부 수동으로 작업하기"},{"content":"react.js에 Sentry를 적용하려고 찾아보던 중에 스프링부트도 대응언어에 포함되어있어서 테스트해 보았습니다.\n버전  Spring Boot 2.4.1 Sentry  sentry-spring-boot-starter 4.3.0    Sentry에 프로젝트 추가 및 설정   Sentry에 로그인 후 프로젝트를 생성합니다.\n  Client Keys (DSN)메뉴에 있는 DSN키를 복사해둡니다.     build.gradle.kts에 의존관계를 추가합니다.\n build.gradle.kts implementation(\u0026quot;io.sentry:sentry-spring-boot-starter:4.3.0\u0026quot;)     application.properties에 DSN (Data Source Name)을 설정합니다.\n application.properties # DSN설정 sentry.dsn=https://xxxxxxxxxxxxxxxxxxxxxxxxxxx@xxxxxx.ingest.sentry.io/xxxxx # 에러 추척 설정 sentry.enable-tracing=true  application-development.properties # 각각의 환경도 설정할 수 있습니다. sentry.environment=development     Sentry에 에러를 보내기 위한 설정\n RestApi프로젝트라 @RestControllerAdvice을 이용하여 공통 예외 처리를 추가했습니다. @RestControllerAdvice class SampleControllerAdvice { @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(MissingPathVariableException::class) fun handleMissingPathVariable(ex: MissingPathVariableException): Map\u0026lt;String, String\u0026gt; { Sentry.captureException(ex) val error: Map\u0026lt;String, String\u0026gt; = mapOf(\u0026quot;code\u0026quot; to \u0026quot;E0001\u0026quot;, \u0026quot;message\u0026quot; to \u0026quot;Parameter error\u0026quot;) return error } @ResponseStatus(HttpStatus.UNSUPPORTED_MEDIA_TYPE) @ExceptionHandler(HttpMediaTypeNotSupportedException::class) fun handleHttpMediaTypeNotSupported(ex: HttpMediaTypeNotSupportedException): Map\u0026lt;String, String\u0026gt; { Sentry.captureException(ex) val error: Map\u0026lt;String, String\u0026gt; = mapOf(\u0026quot;code\u0026quot; to \u0026quot;E0002\u0026quot;, \u0026quot;message\u0026quot; to \u0026quot;Unsupported Media Type\u0026quot;) return error } @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler(Exception::class) fun handleExceptions(ex: Exception): Map\u0026lt;String, String\u0026gt; { Sentry.captureException(ex) val error: Map\u0026lt;String, String\u0026gt; = mapOf(\u0026quot;code\u0026quot; to \u0026quot;E0003\u0026quot;, \u0026quot;message\u0026quot; to \u0026quot;Internal Server Error\u0026quot;) return error } }     에러를 발생시켜 Sentry상세페이지 확인  Content type을 추가해서 에러를 발생시켜보겠습니다.    Search by Trace를 클릭하면 에러 추척도 가능하네요.    Dashboard도 제공하네요.　Custom Dashboards는 Business플랜부터 가능하네요.     slack에 통지  slack이나 타 서비스와 연계하려면 Team플랜부터 가능하네요. slack에 메세지만 통지하는 용도라면 sentry의 WebHooks를 이용하면 Developer(무료)플랜으로도 사용가능합니다.     Business플랜이면 Amazon SQS에 데이터 전송도 가능하다니 편리할 것 같습니다. 나중에 공식사이트 를 꼼꼼히 살펴보아야겠습니다.\n","permalink":"https://bokyung.dev/2021/04/15/sentry-springboot/","summary":"react.js에 Sentry를 적용하려고 찾아보던 중에 스프링부트도 대응언어에 포함되어있어서 테스트해 보았습니다.\n버전  Spring Boot 2.4.1 Sentry  sentry-spring-boot-starter 4.3.0    Sentry에 프로젝트 추가 및 설정   Sentry에 로그인 후 프로젝트를 생성합니다.\n  Client Keys (DSN)메뉴에 있는 DSN키를 복사해둡니다.     build.gradle.kts에 의존관계를 추가합니다.\n build.gradle.kts implementation(\u0026quot;io.sentry:sentry-spring-boot-starter:4.3.0\u0026quot;)     application.properties에 DSN (Data Source Name)을 설정합니다.\n application.properties # DSN설정 sentry.dsn=https://xxxxxxxxxxxxxxxxxxxxxxxxxxx@xxxxxx.ingest.sentry.io/xxxxx # 에러 추척 설정 sentry.","title":"Sentry를 스프링부트 프로젝트에 적용하기"},{"content":"Jenkins에서 스프링 배치 Job을 실행해 보았습니다.\nJenkins 환경  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI 이름 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    환경변수와 플러그인 설정   여러 Job을 등록하는 경우 각각의 Job에서 같은 파라미터를 넘겨주게 되는데 환경변수에 등록해두면 관리하기가 편해집니다.\n  Job파라미터로 실행날짜를 넘겨주기 위해서 timestamper플러그인을 사용하였습니다.     Manage Jenkins \u0026gt; System Configuration \u0026gt; Configure System \u0026gt; Global properties \u0026gt; Environment variables에서 Job에서 공통으로 사용하는 환경변수를 설정합니다.     배치Job등록  New Item \u0026gt; Freestyle project을 선택해서 Job을 등록합니다.     java -jar ${JAR_NAME} ${DB_HOST} ${DB_PORT} ${DB_NAME} ${DB_USER} ${DB_PASSWORD} \\ --spring.batch.job.names=${JOB_NAME} version=${BUILD_NUMBER} requestDate=${BUILD_TIMESTAMP} --spring.batch.job.enabled=true --spring.profiles.active=dev 배치Job실행  Job을 실행하고 실행 결과를 확인합니다.  2021-03-31 13:09:56.358 INFO 3564 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path '' 2021-03-31 13:09:56.379 INFO 3564 --- [ main] c.e.sample.batch.BatchApplicationKt : Started BatchApplicationKt in 12.493 seconds (JVM running for 13.807) 2021-03-31 13:09:56.380 INFO 3564 --- [ main] o.s.b.a.b.JobLauncherApplicationRunner : Running default command line with: [version=17, requestDate=2021-03-31] 2021-03-31 13:09:56.516 INFO 3564 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=jpaJob]] launched with the following parameters: [{requestDate=2021-03-31, version=17}] 2021-03-31 13:09:56.600 INFO 3564 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [jpaPagingItemStep] 2021-03-31 13:09:57.071 INFO 3564 --- [ main] o.s.batch.core.step.AbstractStep : Step: [jpaPagingItemStep] executed in 471ms 2021-03-31 13:09:57.092 INFO 3564 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=jpaJob]] completed with the following parameters: [{requestDate=2021-03-31, version=17}] and the following status: [COMPLETED] in 521ms 2021-03-31 13:09:57.127 INFO 3564 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Shutting down ExecutorService 'applicationTaskExecutor' 2021-03-31 13:09:57.129 INFO 3564 --- [ main] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default' 2021-03-31 13:09:57.140 INFO 3564 --- [ main] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Shutdown initiated... 2021-03-31 13:09:57.155 INFO 3564 --- [ main] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Shutdown completed. Finished: SUCCESS BatchApplication.kt  Job실행 종료시 application도 종료시키기 위한 설정  @EnableBatchProcessing @SpringBootApplication class BatchApplication fun main(args: Array\u0026lt;String\u0026gt;) { val context = runApplication\u0026lt;BatchApplication\u0026gt;(*args) val exitCode = SpringApplication.exit(context) System.exit(exitCode) } ","permalink":"https://bokyung.dev/2021/03/31/jenkins-batch-job/","summary":"Jenkins에서 스프링 배치 Job을 실행해 보았습니다.\nJenkins 환경  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI 이름 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    환경변수와 플러그인 설정   여러 Job을 등록하는 경우 각각의 Job에서 같은 파라미터를 넘겨주게 되는데 환경변수에 등록해두면 관리하기가 편해집니다.\n  Job파라미터로 실행날짜를 넘겨주기 위해서 timestamper플러그인을 사용하였습니다.     Manage Jenkins \u0026gt; System Configuration \u0026gt; Configure System \u0026gt; Global properties \u0026gt; Environment variables에서 Job에서 공통으로 사용하는 환경변수를 설정합니다.","title":"Jenkins에서 Spring Batch Job을 실행하기"},{"content":"스프링 배치 Job Runner를 조사하던 중에 Jenkins에서 batch프로젝트를 gradle빌드해 보았습니다.\nJenkins 환경  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI 이름 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    인증정보 등록 Github 아이디/패스워드 인증 방법   Jenkins에서 Repository관련 작업이 가능하도록 Github에서 Personal access tokens를 발행합니다. ( Settings \u0026gt; Developer settings \u0026gt; Personal access tokens )     Manage Jenkins \u0026gt; Manage Credentials \u0026gt; domain에 있는 global을 클릭합니다.     Kind는 Username with password를 선택하고 패스워드란에 Personal access tokens값을 입력하고 인증정보를 추가합니다.     Github SSH 인증 방법   SSH키를 생성합니다.       Github 프로젝트 설정에서 Deploy keys에 공개키를 추가합니다.     Kind는 SSH Username with private key를 선택하고 Private Key \u0026gt; Enter directly 에 비밀키를 추가합니다.     Gradle, JDK설정  프로젝트에서 사용할 Gradle과 JDK를 Manage Jenkins \u0026gt; System Configuration \u0026gt; Global Tool Configuration에서 설정합니다. 한가지 버전만 설정한 경우 각 JOB에서 디폴트로 설정됩니다. 복수개 버전이 등록된 경우에는 JOB설정시 버전선택이 가능합니다.     Job등록   New Item \u0026gt; Freestyle project을 선택해서 Job을 등록합니다. github access tokens으로 인증할 경우에는 Repository URL에 git@github.com:bokyung-kang/batch-test을 입력하고 Credentials에서 github인증을 등록한 Username을 선택합니다.     ssh인증할 경우에는 Repository URL에 git@github.com:bokyung-kang/batch-test을 입력하고 Credentials에서 ssh을 등록한 Username을 선택합니다.     build script\nchmod +x gradlew # test를 실행안하려고 저는 assemble을 실행했습니다 ./gradlew assemble # deploy-test에 jar복사 mkdir -p $JENKINS_HOME/workspace/deploy-test cp $WORKSPACE/build/libs/*.jar $JENKINS_HOME/workspace/deploy-test/.   Gradle Build  빌드를 실행합니다.  [batch-test] $ /bin/sh -xe /tmp/jenkins568576160326820555.sh + chmod +x gradlew + ./gradlew assemble Starting a Gradle Daemon (subsequent builds will be faster) \u0026gt; Task :compileKotlin \u0026gt; Task :compileJava NO-SOURCE \u0026gt; Task :processResources \u0026gt; Task :classes \u0026gt; Task :bootJarMainClassName \u0026gt; Task :bootJar \u0026gt; Task :inspectClassesForKotlinIC \u0026gt; Task :jar SKIPPED \u0026gt; Task :assemble BUILD SUCCESSFUL in 33s 5 actionable tasks: 5 executed + mkdir -p /var/lib/jenkins/workspace/deploy-test + cp /var/lib/jenkins/workspace/batch-test/build/libs/batch-0.0.1-SNAPSHOT.jar /var/lib/jenkins/workspace/deploy-test/. Finished: SUCCESS  $JENKINS_HOME/workspace/deploy-test/에 jar파일이 복사되었네요.     ","permalink":"https://bokyung.dev/2021/03/30/jenkins-gradle-build/","summary":"스프링 배치 Job Runner를 조사하던 중에 Jenkins에서 batch프로젝트를 gradle빌드해 보았습니다.\nJenkins 환경  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI 이름 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    인증정보 등록 Github 아이디/패스워드 인증 방법   Jenkins에서 Repository관련 작업이 가능하도록 Github에서 Personal access tokens를 발행합니다. ( Settings \u0026gt; Developer settings \u0026gt; Personal access tokens )     Manage Jenkins \u0026gt; Manage Credentials \u0026gt; domain에 있는 global을 클릭합니다.","title":"Jenkins에서 Spring Batch 프로젝트를 Gradle 빌드하기"},{"content":"로컬 도커환경에서 Jenkins를 테스트 하던 중에 에러가 나는 경우가 있어서 검증을 위해서 Amazon Linux2에 Jenkins를 설치 해 보았습니다.\n설치한 Jenkins 환경  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI 이름 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    EC2 인스턴스 생성 및 Jenkins설치 EC2 인스턴스 생성 및 보안그룹 설정   맨위에 표시되는 AMI로 생성했습니다.     젠킨스 접속용 8080포트와 SSH접속용 22번 포트를 설정합니다.     Jenkins 설치  Jenkins 공홈 설치 방법 에 나와있는 순서대로 설치하였습니다.  sudo wget -O /etc/yum.repos.d/jenkins.repo \\ https://pkg.jenkins.io/redhat-stable/jenkins.repo sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key sudo yum upgrade sudo yum install jenkins java-1.8.0-openjdk-devel.x86_64 sudo systemctl daemon-reload Jenkins 실행 sudo systemctl start jenkins 서비스 실행 상태를 확인하여, active상태인 것을 확인합니다.   Jenkins 초기 설정   Jenkins에 접속합니다. http://xxxxxxxxxx:8080/\n  초기패스워드를 화면에 입력합니다.     추천플러그인을 설치합니다.     초기유저를 등록합니다.     인스턴스 접속주소를 등록합니다.     설정이 완료되었습니다.     메인화면이 표시되었습니다.     ","permalink":"https://bokyung.dev/2021/03/17/jenkins-install/","summary":"로컬 도커환경에서 Jenkins를 테스트 하던 중에 에러가 나는 경우가 있어서 검증을 위해서 Amazon Linux2에 Jenkins를 설치 해 보았습니다.\n설치한 Jenkins 환경  Amazon Linux2  AMI ID : ami-0f27d081df46f326c AMI 이름 : amzn2-ami-hvm-2.0.20210303.0-x86_64-gp2   Jenkins  version : Jenkins 2.284    EC2 인스턴스 생성 및 Jenkins설치 EC2 인스턴스 생성 및 보안그룹 설정   맨위에 표시되는 AMI로 생성했습니다.     젠킨스 접속용 8080포트와 SSH접속용 22번 포트를 설정합니다.","title":"Amazon Linux2에 Jenkins 설치하기"},{"content":"springboot + kotlin으로 개발한 backendAPI를 CircleCI로 배포하고 있습니다. staging/production 환경별 환경변수를 Contexts를 이용하면 좀 더 편리하게 설정할 수 있습니다.\nContexts 설정 Organization Settings \u0026gt; Contexts 에서 서비스의 각 환경별 환경변수를 설정합니다. staging/production 환경 이름으로 등록했습니다.   staging 환경의 환경변수입니다. ecr와 ecs용 orbs를 이용하기 위해서 AWS 환경변수를 추가하고 프로젝트에서 공통으로 사용하기 위해서 SERVICE_PREFIX를 추가했습니다.   CircleCI config.yml 설정 build-and-push-image  backend-build를 실행합니다. release 브랜치인 경우 build-and-push-image-staging을 실행합니다. master 브랜치인 경우 build-and-push-image-production을 실행합니다. context에는 CircleCI Contexts에서 지정한 이름을 추가합니다.  version: 2.1 orbs: aws-ecr: circleci/aws-ecr@6.15.3 aws-ecs: circleci/aws-ecs@1.4.0 gradle: circleci/gradle@2.2.0 executors: openjdk-executor: docker: - image: circleci/openjdk:14-jdk-buster-node-browsers ..... jobs: backend-build: executor: openjdk-executor ..... workflows: build-deploy: jobs: - backend-build - aws-ecr/build-and-push-image: name: build-and-push-image-staging requires: - backend-build context: DEMO_STAGING attach-workspace: true checkout: false repo: \u0026#39;${SERVICE_PREFIX}\u0026#39; tag: \u0026#39;latest,${CIRCLE_SHA1}\u0026#39; filters: branches: only: - /release\\/.*/ - aws-ecr/build-and-push-image: name: build-and-push-image-production requires: - backend-build context: DEMO_PRODUCTION attach-workspace: true checkout: false repo: \u0026#39;${SERVICE_PREFIX}\u0026#39; tag: \u0026#39;latest,${CIRCLE_SHA1}\u0026#39; filters: branches: only: - master deploy-service-update  backend-build를 실행합니다. release 브랜치인 경우 build-and-push-image-staging의 실행이 완료되면 deploy-service-update-staging을 실행합니다. master 브랜치인 경우 build-and-push-image-production의 실행이 완료되면 build-and-push-image-production을 실행합니다. context에는 CircleCI Contexts에서 지정한 이름을 추가합니다.  - aws-ecs/deploy-service-update: name: deploy-service-update-staging requires: - build-and-push-image-staging context: DEMO_STAGING family: \u0026#39;${SERVICE_PREFIX}-backend\u0026#39; cluster-name: \u0026#39;${SERVICE_PREFIX}-backend\u0026#39; service-name: \u0026#39;${SERVICE_PREFIX}-backend-ec2-service\u0026#39; container-image-name-updates: \u0026#39;container=${SERVICE_PREFIX}-backend,tag=${CIRCLE_SHA1}\u0026#39; filters: branches: only: - /release\\/.*/ - aws-ecs/deploy-service-update: name: deploy-service-update-production requires: - build-and-push-image-production context: DEMO_PRODUCTION family: \u0026#39;${SERVICE_PREFIX}-backend\u0026#39; cluster-name: \u0026#39;${SERVICE_PREFIX}-backend\u0026#39; service-name: \u0026#39;${SERVICE_PREFIX}-backend-ec2-service\u0026#39; container-image-name-updates: \u0026#39;container=${SERVICE_PREFIX}-backend,tag=${CIRCLE_SHA1}\u0026#39; filters: branches: only: - master CircleCI 배포 release/20210202_1 브랜치를 push   새 작업정의가 등록된것을 확인 task-definition/*****-backend:5   AWS ECS 확인  작업정의 demo1-backend:5로 작업이 기동된 것을 확인할 수 있습니다.     ","permalink":"https://bokyung.dev/2021/02/02/clrcleci-ecs-deploy/","summary":"springboot + kotlin으로 개발한 backendAPI를 CircleCI로 배포하고 있습니다. staging/production 환경별 환경변수를 Contexts를 이용하면 좀 더 편리하게 설정할 수 있습니다.\nContexts 설정 Organization Settings \u0026gt; Contexts 에서 서비스의 각 환경별 환경변수를 설정합니다. staging/production 환경 이름으로 등록했습니다.   staging 환경의 환경변수입니다. ecr와 ecs용 orbs를 이용하기 위해서 AWS 환경변수를 추가하고 프로젝트에서 공통으로 사용하기 위해서 SERVICE_PREFIX를 추가했습니다.   CircleCI config.yml 설정 build-and-push-image  backend-build를 실행합니다. release 브랜치인 경우 build-and-push-image-staging을 실행합니다. master 브랜치인 경우 build-and-push-image-production을 실행합니다.","title":"CircleCI의 Contexts를 이용하여 AWS ECS 자동 배포하기"}]